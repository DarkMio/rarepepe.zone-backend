/* tslint:disable */
/* eslint-disable */
/**
 * Discord HTTP API (Preview)
 * Preview of the Discord v10 HTTP API specification. See https://discord.com/developers/docs for more details.
 *
 * The version of the OpenAPI document: 10
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "../configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "../common";
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, operationServerMap } from "../base";
// @ts-ignore
import { AddGroupDmUserRequest } from "../models";
// @ts-ignore
import { AddGuildMemberRequest } from "../models";
// @ts-ignore
import { ApplicationCommandCreateRequest } from "../models";
// @ts-ignore
import { ApplicationCommandPatchRequestPartial } from "../models";
// @ts-ignore
import { ApplicationCommandResponse } from "../models";
// @ts-ignore
import { ApplicationCommandUpdateRequest } from "../models";
// @ts-ignore
import { ApplicationFormPartial } from "../models";
// @ts-ignore
import { ApplicationRoleConnectionsMetadataItemRequest } from "../models";
// @ts-ignore
import { ApplicationRoleConnectionsMetadataItemResponse } from "../models";
// @ts-ignore
import { ApplicationUserRoleConnectionResponse } from "../models";
// @ts-ignore
import { BanUserFromGuildRequest } from "../models";
// @ts-ignore
import { BotAccountPatchRequest } from "../models";
// @ts-ignore
import { BulkDeleteMessagesRequest } from "../models";
// @ts-ignore
import { BulkUpdateGuildChannelsRequestInner } from "../models";
// @ts-ignore
import { BulkUpdateGuildRolesRequestInner } from "../models";
// @ts-ignore
import { ChannelFollowerResponse } from "../models";
// @ts-ignore
import { CommandPermissionsResponse } from "../models";
// @ts-ignore
import { ConnectedAccountResponse } from "../models";
// @ts-ignore
import { CreateAutoModerationRuleRequest } from "../models";
// @ts-ignore
import { CreateChannelInviteRequest } from "../models";
// @ts-ignore
import { CreateDm200Response } from "../models";
// @ts-ignore
import { CreateGuildChannelRequest } from "../models";
// @ts-ignore
import { CreateGuildEmojiRequest } from "../models";
// @ts-ignore
import { CreateGuildFromTemplateRequest } from "../models";
// @ts-ignore
import { CreateGuildScheduledEventRequest } from "../models";
// @ts-ignore
import { CreateGuildTemplateRequest } from "../models";
// @ts-ignore
import { CreateInteractionResponseRequest } from "../models";
// @ts-ignore
import { CreateMessageRequest } from "../models";
// @ts-ignore
import { CreatePrivateChannelRequest } from "../models";
// @ts-ignore
import { CreateStageInstanceRequest } from "../models";
// @ts-ignore
import { CreateTextThreadWithMessageRequest } from "../models";
// @ts-ignore
import { CreateThreadRequest } from "../models";
// @ts-ignore
import { CreateWebhookRequest } from "../models";
// @ts-ignore
import { CreatedThreadResponse } from "../models";
// @ts-ignore
import { EmojiResponse } from "../models";
// @ts-ignore
import { ErrorResponse } from "../models";
// @ts-ignore
import { ExecuteWebhookRequest } from "../models";
// @ts-ignore
import { FollowChannelRequest } from "../models";
// @ts-ignore
import { GatewayBotResponse } from "../models";
// @ts-ignore
import { GatewayResponse } from "../models";
// @ts-ignore
import { GetAutoModerationRule200Response } from "../models";
// @ts-ignore
import { GetGuildScheduledEvent200Response } from "../models";
// @ts-ignore
import { GetSticker200Response } from "../models";
// @ts-ignore
import { GithubWebhook } from "../models";
// @ts-ignore
import { GuildAuditLogResponse } from "../models";
// @ts-ignore
import { GuildBanResponse } from "../models";
// @ts-ignore
import { GuildChannelResponse } from "../models";
// @ts-ignore
import { GuildCreateRequest } from "../models";
// @ts-ignore
import { GuildHomeSettingsResponse } from "../models";
// @ts-ignore
import { GuildIncomingWebhookResponse } from "../models";
// @ts-ignore
import { GuildMFALevelResponse } from "../models";
// @ts-ignore
import { GuildMemberResponse } from "../models";
// @ts-ignore
import { GuildOnboardingResponse } from "../models";
// @ts-ignore
import { GuildPatchRequestPartial } from "../models";
// @ts-ignore
import { GuildPreviewResponse } from "../models";
// @ts-ignore
import { GuildPruneResponse } from "../models";
// @ts-ignore
import { GuildResponse } from "../models";
// @ts-ignore
import { GuildRoleResponse } from "../models";
// @ts-ignore
import { GuildStickerResponse } from "../models";
// @ts-ignore
import { GuildTemplateResponse } from "../models";
// @ts-ignore
import { GuildWelcomeScreenResponse } from "../models";
// @ts-ignore
import { GuildWithCountsResponse } from "../models";
// @ts-ignore
import { IncomingWebhookUpdateRequestPartial } from "../models";
// @ts-ignore
import { ListAutoModerationRules200ResponseInner } from "../models";
// @ts-ignore
import { ListChannelInvites200ResponseInner } from "../models";
// @ts-ignore
import { ListChannelWebhooks200ResponseInner } from "../models";
// @ts-ignore
import { ListGuildChannels200ResponseInner } from "../models";
// @ts-ignore
import { ListGuildIntegrations200ResponseInner } from "../models";
// @ts-ignore
import { MessageCreateRequest } from "../models";
// @ts-ignore
import { MessageEditRequestPartial } from "../models";
// @ts-ignore
import { MessageResponse } from "../models";
// @ts-ignore
import { MyGuildResponse } from "../models";
// @ts-ignore
import { OAuth2GetAuthorizationResponse } from "../models";
// @ts-ignore
import { PrivateApplicationResponse } from "../models";
// @ts-ignore
import { PrivateGuildMemberResponse } from "../models";
// @ts-ignore
import { PruneGuildRequest } from "../models";
// @ts-ignore
import { ScheduledEventUserResponse } from "../models";
// @ts-ignore
import { SetChannelPermissionOverwriteRequest } from "../models";
// @ts-ignore
import { SetGuildApplicationCommandPermissionsRequest } from "../models";
// @ts-ignore
import { SetGuildMfaLevelRequest } from "../models";
// @ts-ignore
import { SlackWebhook } from "../models";
// @ts-ignore
import { StageInstanceResponse } from "../models";
// @ts-ignore
import { StickerPackCollectionResponse } from "../models";
// @ts-ignore
import { ThreadMemberResponse } from "../models";
// @ts-ignore
import { ThreadResponse } from "../models";
// @ts-ignore
import { ThreadsResponse } from "../models";
// @ts-ignore
import { UpdateApplicationUserRoleConnectionRequest } from "../models";
// @ts-ignore
import { UpdateAutoModerationRuleRequest } from "../models";
// @ts-ignore
import { UpdateChannelRequest } from "../models";
// @ts-ignore
import { UpdateGuildEmojiRequest } from "../models";
// @ts-ignore
import { UpdateGuildMemberRequest } from "../models";
// @ts-ignore
import { UpdateGuildOnboardingRequest } from "../models";
// @ts-ignore
import { UpdateGuildRoleRequest } from "../models";
// @ts-ignore
import { UpdateGuildScheduledEventRequest } from "../models";
// @ts-ignore
import { UpdateGuildStickerRequest } from "../models";
// @ts-ignore
import { UpdateGuildTemplateRequest } from "../models";
// @ts-ignore
import { UpdateGuildWidgetSettingsRequest } from "../models";
// @ts-ignore
import { UpdateMessageRequest } from "../models";
// @ts-ignore
import { UpdateMyGuildMemberRequest } from "../models";
// @ts-ignore
import { UpdateOriginalWebhookMessageRequest } from "../models";
// @ts-ignore
import { UpdateSelfVoiceStateRequest } from "../models";
// @ts-ignore
import { UpdateStageInstanceRequest } from "../models";
// @ts-ignore
import { UpdateVoiceStateRequest } from "../models";
// @ts-ignore
import { UpdateWebhookByTokenRequest } from "../models";
// @ts-ignore
import { UpdateWebhookRequest } from "../models";
// @ts-ignore
import { UserGuildOnboardingResponse } from "../models";
// @ts-ignore
import { UserPIIResponse } from "../models";
// @ts-ignore
import { UserResponse } from "../models";
// @ts-ignore
import { VanityURLResponse } from "../models";
// @ts-ignore
import { VoiceRegionResponse } from "../models";
// @ts-ignore
import { WelcomeScreenPatchRequestPartial } from "../models";
// @ts-ignore
import { WidgetImageStyles } from "../models";
// @ts-ignore
import { WidgetResponse } from "../models";
// @ts-ignore
import { WidgetSettingsResponse } from "../models";
/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {any} channelId
     * @param {any} userId
     * @param {AddGroupDmUserRequest} addGroupDmUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGroupDmUser: async (
      channelId: any,
      userId: any,
      addGroupDmUserRequest: AddGroupDmUserRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("addGroupDmUser", "channelId", channelId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("addGroupDmUser", "userId", userId);
      // verify required parameter 'addGroupDmUserRequest' is not null or undefined
      assertParamExists("addGroupDmUser", "addGroupDmUserRequest", addGroupDmUserRequest);
      const localVarPath = `/channels/{channel_id}/recipients/{user_id}`
        .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
        .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(addGroupDmUserRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {AddGuildMemberRequest} addGuildMemberRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGuildMember: async (
      guildId: any,
      userId: any,
      addGuildMemberRequest: AddGuildMemberRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("addGuildMember", "guildId", guildId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("addGuildMember", "userId", userId);
      // verify required parameter 'addGuildMemberRequest' is not null or undefined
      assertParamExists("addGuildMember", "addGuildMemberRequest", addGuildMemberRequest);
      const localVarPath = `/guilds/{guild_id}/members/{user_id}`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(addGuildMemberRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {any} roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGuildMemberRole: async (
      guildId: any,
      userId: any,
      roleId: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("addGuildMemberRole", "guildId", guildId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("addGuildMemberRole", "userId", userId);
      // verify required parameter 'roleId' is not null or undefined
      assertParamExists("addGuildMemberRole", "roleId", roleId);
      const localVarPath = `/guilds/{guild_id}/members/{user_id}/roles/{role_id}`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
        .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {string} emojiName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addMyMessageReaction: async (
      channelId: any,
      messageId: any,
      emojiName: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("addMyMessageReaction", "channelId", channelId);
      // verify required parameter 'messageId' is not null or undefined
      assertParamExists("addMyMessageReaction", "messageId", messageId);
      // verify required parameter 'emojiName' is not null or undefined
      assertParamExists("addMyMessageReaction", "emojiName", emojiName);
      const localVarPath = `/channels/{channel_id}/messages/{message_id}/reactions/{emoji_name}/@me`
        .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
        .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)))
        .replace(`{${"emoji_name"}}`, encodeURIComponent(String(emojiName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {any} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addThreadMember: async (channelId: any, userId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("addThreadMember", "channelId", channelId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("addThreadMember", "userId", userId);
      const localVarPath = `/channels/{channel_id}/thread-members/{user_id}`
        .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
        .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {BanUserFromGuildRequest} banUserFromGuildRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    banUserFromGuild: async (
      guildId: any,
      userId: any,
      banUserFromGuildRequest: BanUserFromGuildRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("banUserFromGuild", "guildId", guildId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("banUserFromGuild", "userId", userId);
      // verify required parameter 'banUserFromGuildRequest' is not null or undefined
      assertParamExists("banUserFromGuild", "banUserFromGuildRequest", banUserFromGuildRequest);
      const localVarPath = `/guilds/{guild_id}/bans/{user_id}`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        banUserFromGuildRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {BulkDeleteMessagesRequest} bulkDeleteMessagesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkDeleteMessages: async (
      channelId: any,
      bulkDeleteMessagesRequest: BulkDeleteMessagesRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("bulkDeleteMessages", "channelId", channelId);
      // verify required parameter 'bulkDeleteMessagesRequest' is not null or undefined
      assertParamExists("bulkDeleteMessages", "bulkDeleteMessagesRequest", bulkDeleteMessagesRequest);
      const localVarPath = `/channels/{channel_id}/messages/bulk-delete`.replace(
        `{${"channel_id"}}`,
        encodeURIComponent(String(channelId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        bulkDeleteMessagesRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} applicationId
     * @param {Array<ApplicationCommandUpdateRequest>} applicationCommandUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkSetApplicationCommands: async (
      applicationId: any,
      applicationCommandUpdateRequest: Array<ApplicationCommandUpdateRequest>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'applicationId' is not null or undefined
      assertParamExists("bulkSetApplicationCommands", "applicationId", applicationId);
      // verify required parameter 'applicationCommandUpdateRequest' is not null or undefined
      assertParamExists(
        "bulkSetApplicationCommands",
        "applicationCommandUpdateRequest",
        applicationCommandUpdateRequest,
      );
      const localVarPath = `/applications/{application_id}/commands`.replace(
        `{${"application_id"}}`,
        encodeURIComponent(String(applicationId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.update"], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration);

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        applicationCommandUpdateRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} guildId
     * @param {Array<ApplicationCommandUpdateRequest>} applicationCommandUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkSetGuildApplicationCommands: async (
      applicationId: any,
      guildId: any,
      applicationCommandUpdateRequest: Array<ApplicationCommandUpdateRequest>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'applicationId' is not null or undefined
      assertParamExists("bulkSetGuildApplicationCommands", "applicationId", applicationId);
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("bulkSetGuildApplicationCommands", "guildId", guildId);
      // verify required parameter 'applicationCommandUpdateRequest' is not null or undefined
      assertParamExists(
        "bulkSetGuildApplicationCommands",
        "applicationCommandUpdateRequest",
        applicationCommandUpdateRequest,
      );
      const localVarPath = `/applications/{application_id}/guilds/{guild_id}/commands`
        .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.update"], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration);

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        applicationCommandUpdateRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {Array<BulkUpdateGuildChannelsRequestInner>} bulkUpdateGuildChannelsRequestInner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkUpdateGuildChannels: async (
      guildId: any,
      bulkUpdateGuildChannelsRequestInner: Array<BulkUpdateGuildChannelsRequestInner>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("bulkUpdateGuildChannels", "guildId", guildId);
      // verify required parameter 'bulkUpdateGuildChannelsRequestInner' is not null or undefined
      assertParamExists(
        "bulkUpdateGuildChannels",
        "bulkUpdateGuildChannelsRequestInner",
        bulkUpdateGuildChannelsRequestInner,
      );
      const localVarPath = `/guilds/{guild_id}/channels`.replace(
        `{${"guild_id"}}`,
        encodeURIComponent(String(guildId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        bulkUpdateGuildChannelsRequestInner,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {Array<BulkUpdateGuildRolesRequestInner>} bulkUpdateGuildRolesRequestInner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkUpdateGuildRoles: async (
      guildId: any,
      bulkUpdateGuildRolesRequestInner: Array<BulkUpdateGuildRolesRequestInner>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("bulkUpdateGuildRoles", "guildId", guildId);
      // verify required parameter 'bulkUpdateGuildRolesRequestInner' is not null or undefined
      assertParamExists("bulkUpdateGuildRoles", "bulkUpdateGuildRolesRequestInner", bulkUpdateGuildRolesRequestInner);
      const localVarPath = `/guilds/{guild_id}/roles`.replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        bulkUpdateGuildRolesRequestInner,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} applicationId
     * @param {ApplicationCommandCreateRequest} applicationCommandCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApplicationCommand: async (
      applicationId: any,
      applicationCommandCreateRequest: ApplicationCommandCreateRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'applicationId' is not null or undefined
      assertParamExists("createApplicationCommand", "applicationId", applicationId);
      // verify required parameter 'applicationCommandCreateRequest' is not null or undefined
      assertParamExists("createApplicationCommand", "applicationCommandCreateRequest", applicationCommandCreateRequest);
      const localVarPath = `/applications/{application_id}/commands`.replace(
        `{${"application_id"}}`,
        encodeURIComponent(String(applicationId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.update"], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration);

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        applicationCommandCreateRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {CreateAutoModerationRuleRequest} createAutoModerationRuleRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAutoModerationRule: async (
      guildId: any,
      createAutoModerationRuleRequest: CreateAutoModerationRuleRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("createAutoModerationRule", "guildId", guildId);
      // verify required parameter 'createAutoModerationRuleRequest' is not null or undefined
      assertParamExists("createAutoModerationRule", "createAutoModerationRuleRequest", createAutoModerationRuleRequest);
      const localVarPath = `/guilds/{guild_id}/auto-moderation/rules`.replace(
        `{${"guild_id"}}`,
        encodeURIComponent(String(guildId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createAutoModerationRuleRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {CreateChannelInviteRequest} createChannelInviteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createChannelInvite: async (
      channelId: any,
      createChannelInviteRequest: CreateChannelInviteRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("createChannelInvite", "channelId", channelId);
      // verify required parameter 'createChannelInviteRequest' is not null or undefined
      assertParamExists("createChannelInvite", "createChannelInviteRequest", createChannelInviteRequest);
      const localVarPath = `/channels/{channel_id}/invites`.replace(
        `{${"channel_id"}}`,
        encodeURIComponent(String(channelId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createChannelInviteRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CreatePrivateChannelRequest} createPrivateChannelRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDm: async (
      createPrivateChannelRequest: CreatePrivateChannelRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createPrivateChannelRequest' is not null or undefined
      assertParamExists("createDm", "createPrivateChannelRequest", createPrivateChannelRequest);
      const localVarPath = `/users/@me/channels`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createPrivateChannelRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GuildCreateRequest} guildCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGuild: async (
      guildCreateRequest: GuildCreateRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildCreateRequest' is not null or undefined
      assertParamExists("createGuild", "guildCreateRequest", guildCreateRequest);
      const localVarPath = `/guilds`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(guildCreateRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} guildId
     * @param {ApplicationCommandCreateRequest} applicationCommandCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGuildApplicationCommand: async (
      applicationId: any,
      guildId: any,
      applicationCommandCreateRequest: ApplicationCommandCreateRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'applicationId' is not null or undefined
      assertParamExists("createGuildApplicationCommand", "applicationId", applicationId);
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("createGuildApplicationCommand", "guildId", guildId);
      // verify required parameter 'applicationCommandCreateRequest' is not null or undefined
      assertParamExists(
        "createGuildApplicationCommand",
        "applicationCommandCreateRequest",
        applicationCommandCreateRequest,
      );
      const localVarPath = `/applications/{application_id}/guilds/{guild_id}/commands`
        .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.update"], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration);

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        applicationCommandCreateRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {CreateGuildChannelRequest} createGuildChannelRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGuildChannel: async (
      guildId: any,
      createGuildChannelRequest: CreateGuildChannelRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("createGuildChannel", "guildId", guildId);
      // verify required parameter 'createGuildChannelRequest' is not null or undefined
      assertParamExists("createGuildChannel", "createGuildChannelRequest", createGuildChannelRequest);
      const localVarPath = `/guilds/{guild_id}/channels`.replace(
        `{${"guild_id"}}`,
        encodeURIComponent(String(guildId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createGuildChannelRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {CreateGuildEmojiRequest} createGuildEmojiRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGuildEmoji: async (
      guildId: any,
      createGuildEmojiRequest: CreateGuildEmojiRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("createGuildEmoji", "guildId", guildId);
      // verify required parameter 'createGuildEmojiRequest' is not null or undefined
      assertParamExists("createGuildEmoji", "createGuildEmojiRequest", createGuildEmojiRequest);
      const localVarPath = `/guilds/{guild_id}/emojis`.replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createGuildEmojiRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} code
     * @param {CreateGuildFromTemplateRequest} createGuildFromTemplateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGuildFromTemplate: async (
      code: string,
      createGuildFromTemplateRequest: CreateGuildFromTemplateRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'code' is not null or undefined
      assertParamExists("createGuildFromTemplate", "code", code);
      // verify required parameter 'createGuildFromTemplateRequest' is not null or undefined
      assertParamExists("createGuildFromTemplate", "createGuildFromTemplateRequest", createGuildFromTemplateRequest);
      const localVarPath = `/guilds/templates/{code}`.replace(`{${"code"}}`, encodeURIComponent(String(code)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createGuildFromTemplateRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {UpdateGuildRoleRequest} updateGuildRoleRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGuildRole: async (
      guildId: any,
      updateGuildRoleRequest: UpdateGuildRoleRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("createGuildRole", "guildId", guildId);
      // verify required parameter 'updateGuildRoleRequest' is not null or undefined
      assertParamExists("createGuildRole", "updateGuildRoleRequest", updateGuildRoleRequest);
      const localVarPath = `/guilds/{guild_id}/roles`.replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateGuildRoleRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {CreateGuildScheduledEventRequest} createGuildScheduledEventRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGuildScheduledEvent: async (
      guildId: any,
      createGuildScheduledEventRequest: CreateGuildScheduledEventRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("createGuildScheduledEvent", "guildId", guildId);
      // verify required parameter 'createGuildScheduledEventRequest' is not null or undefined
      assertParamExists(
        "createGuildScheduledEvent",
        "createGuildScheduledEventRequest",
        createGuildScheduledEventRequest,
      );
      const localVarPath = `/guilds/{guild_id}/scheduled-events`.replace(
        `{${"guild_id"}}`,
        encodeURIComponent(String(guildId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createGuildScheduledEventRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {string} name
     * @param {string} tags
     * @param {string} file
     * @param {string | null} [description]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGuildSticker: async (
      guildId: any,
      name: string,
      tags: string,
      file: string,
      description?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("createGuildSticker", "guildId", guildId);
      // verify required parameter 'name' is not null or undefined
      assertParamExists("createGuildSticker", "name", name);
      // verify required parameter 'tags' is not null or undefined
      assertParamExists("createGuildSticker", "tags", tags);
      // verify required parameter 'file' is not null or undefined
      assertParamExists("createGuildSticker", "file", file);
      const localVarPath = `/guilds/{guild_id}/stickers`.replace(
        `{${"guild_id"}}`,
        encodeURIComponent(String(guildId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (name !== undefined) {
        localVarFormParams.append("name", name as any);
      }

      if (tags !== undefined) {
        localVarFormParams.append("tags", tags as any);
      }

      if (description !== undefined) {
        localVarFormParams.append("description", description as any);
      }

      if (file !== undefined) {
        localVarFormParams.append("file", file as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {CreateGuildTemplateRequest} createGuildTemplateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGuildTemplate: async (
      guildId: any,
      createGuildTemplateRequest: CreateGuildTemplateRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("createGuildTemplate", "guildId", guildId);
      // verify required parameter 'createGuildTemplateRequest' is not null or undefined
      assertParamExists("createGuildTemplate", "createGuildTemplateRequest", createGuildTemplateRequest);
      const localVarPath = `/guilds/{guild_id}/templates`.replace(
        `{${"guild_id"}}`,
        encodeURIComponent(String(guildId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createGuildTemplateRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} interactionId
     * @param {string} interactionToken
     * @param {CreateInteractionResponseRequest} createInteractionResponseRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInteractionResponse: async (
      interactionId: any,
      interactionToken: string,
      createInteractionResponseRequest: CreateInteractionResponseRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'interactionId' is not null or undefined
      assertParamExists("createInteractionResponse", "interactionId", interactionId);
      // verify required parameter 'interactionToken' is not null or undefined
      assertParamExists("createInteractionResponse", "interactionToken", interactionToken);
      // verify required parameter 'createInteractionResponseRequest' is not null or undefined
      assertParamExists(
        "createInteractionResponse",
        "createInteractionResponseRequest",
        createInteractionResponseRequest,
      );
      const localVarPath = `/interactions/{interaction_id}/{interaction_token}/callback`
        .replace(`{${"interaction_id"}}`, encodeURIComponent(String(interactionId)))
        .replace(`{${"interaction_token"}}`, encodeURIComponent(String(interactionToken)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createInteractionResponseRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {MessageCreateRequest} messageCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMessage: async (
      channelId: any,
      messageCreateRequest: MessageCreateRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("createMessage", "channelId", channelId);
      // verify required parameter 'messageCreateRequest' is not null or undefined
      assertParamExists("createMessage", "messageCreateRequest", messageCreateRequest);
      const localVarPath = `/channels/{channel_id}/messages`.replace(
        `{${"channel_id"}}`,
        encodeURIComponent(String(channelId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(messageCreateRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CreateStageInstanceRequest} createStageInstanceRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createStageInstance: async (
      createStageInstanceRequest: CreateStageInstanceRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createStageInstanceRequest' is not null or undefined
      assertParamExists("createStageInstance", "createStageInstanceRequest", createStageInstanceRequest);
      const localVarPath = `/stage-instances`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createStageInstanceRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {CreateThreadRequest} createThreadRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createThread: async (
      channelId: any,
      createThreadRequest: CreateThreadRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("createThread", "channelId", channelId);
      // verify required parameter 'createThreadRequest' is not null or undefined
      assertParamExists("createThread", "createThreadRequest", createThreadRequest);
      const localVarPath = `/channels/{channel_id}/threads`.replace(
        `{${"channel_id"}}`,
        encodeURIComponent(String(channelId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createThreadRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {CreateTextThreadWithMessageRequest} createTextThreadWithMessageRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createThreadFromMessage: async (
      channelId: any,
      messageId: any,
      createTextThreadWithMessageRequest: CreateTextThreadWithMessageRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("createThreadFromMessage", "channelId", channelId);
      // verify required parameter 'messageId' is not null or undefined
      assertParamExists("createThreadFromMessage", "messageId", messageId);
      // verify required parameter 'createTextThreadWithMessageRequest' is not null or undefined
      assertParamExists(
        "createThreadFromMessage",
        "createTextThreadWithMessageRequest",
        createTextThreadWithMessageRequest,
      );
      const localVarPath = `/channels/{channel_id}/messages/{message_id}/threads`
        .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
        .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createTextThreadWithMessageRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {CreateWebhookRequest} createWebhookRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWebhook: async (
      channelId: any,
      createWebhookRequest: CreateWebhookRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("createWebhook", "channelId", channelId);
      // verify required parameter 'createWebhookRequest' is not null or undefined
      assertParamExists("createWebhook", "createWebhookRequest", createWebhookRequest);
      const localVarPath = `/channels/{channel_id}/webhooks`.replace(
        `{${"channel_id"}}`,
        encodeURIComponent(String(channelId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(createWebhookRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crosspostMessage: async (
      channelId: any,
      messageId: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("crosspostMessage", "channelId", channelId);
      // verify required parameter 'messageId' is not null or undefined
      assertParamExists("crosspostMessage", "messageId", messageId);
      const localVarPath = `/channels/{channel_id}/messages/{message_id}/crosspost`
        .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
        .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllMessageReactions: async (
      channelId: any,
      messageId: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("deleteAllMessageReactions", "channelId", channelId);
      // verify required parameter 'messageId' is not null or undefined
      assertParamExists("deleteAllMessageReactions", "messageId", messageId);
      const localVarPath = `/channels/{channel_id}/messages/{message_id}/reactions`
        .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
        .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {string} emojiName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllMessageReactionsByEmoji: async (
      channelId: any,
      messageId: any,
      emojiName: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("deleteAllMessageReactionsByEmoji", "channelId", channelId);
      // verify required parameter 'messageId' is not null or undefined
      assertParamExists("deleteAllMessageReactionsByEmoji", "messageId", messageId);
      // verify required parameter 'emojiName' is not null or undefined
      assertParamExists("deleteAllMessageReactionsByEmoji", "emojiName", emojiName);
      const localVarPath = `/channels/{channel_id}/messages/{message_id}/reactions/{emoji_name}`
        .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
        .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)))
        .replace(`{${"emoji_name"}}`, encodeURIComponent(String(emojiName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} commandId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApplicationCommand: async (
      applicationId: any,
      commandId: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'applicationId' is not null or undefined
      assertParamExists("deleteApplicationCommand", "applicationId", applicationId);
      // verify required parameter 'commandId' is not null or undefined
      assertParamExists("deleteApplicationCommand", "commandId", commandId);
      const localVarPath = `/applications/{application_id}/commands/{command_id}`
        .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
        .replace(`{${"command_id"}}`, encodeURIComponent(String(commandId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.update"], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration);

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {any} ruleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAutoModerationRule: async (
      guildId: any,
      ruleId: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("deleteAutoModerationRule", "guildId", guildId);
      // verify required parameter 'ruleId' is not null or undefined
      assertParamExists("deleteAutoModerationRule", "ruleId", ruleId);
      const localVarPath = `/guilds/{guild_id}/auto-moderation/rules/{rule_id}`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteChannel: async (channelId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("deleteChannel", "channelId", channelId);
      const localVarPath = `/channels/{channel_id}`.replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {any} overwriteId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteChannelPermissionOverwrite: async (
      channelId: any,
      overwriteId: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("deleteChannelPermissionOverwrite", "channelId", channelId);
      // verify required parameter 'overwriteId' is not null or undefined
      assertParamExists("deleteChannelPermissionOverwrite", "overwriteId", overwriteId);
      const localVarPath = `/channels/{channel_id}/permissions/{overwrite_id}`
        .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
        .replace(`{${"overwrite_id"}}`, encodeURIComponent(String(overwriteId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {any} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroupDmUser: async (
      channelId: any,
      userId: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("deleteGroupDmUser", "channelId", channelId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("deleteGroupDmUser", "userId", userId);
      const localVarPath = `/channels/{channel_id}/recipients/{user_id}`
        .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
        .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGuild: async (guildId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("deleteGuild", "guildId", guildId);
      const localVarPath = `/guilds/{guild_id}`.replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} guildId
     * @param {any} commandId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGuildApplicationCommand: async (
      applicationId: any,
      guildId: any,
      commandId: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'applicationId' is not null or undefined
      assertParamExists("deleteGuildApplicationCommand", "applicationId", applicationId);
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("deleteGuildApplicationCommand", "guildId", guildId);
      // verify required parameter 'commandId' is not null or undefined
      assertParamExists("deleteGuildApplicationCommand", "commandId", commandId);
      const localVarPath = `/applications/{application_id}/guilds/{guild_id}/commands/{command_id}`
        .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"command_id"}}`, encodeURIComponent(String(commandId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.update"], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration);

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {any} emojiId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGuildEmoji: async (guildId: any, emojiId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("deleteGuildEmoji", "guildId", guildId);
      // verify required parameter 'emojiId' is not null or undefined
      assertParamExists("deleteGuildEmoji", "emojiId", emojiId);
      const localVarPath = `/guilds/{guild_id}/emojis/{emoji_id}`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"emoji_id"}}`, encodeURIComponent(String(emojiId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {any} integrationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGuildIntegration: async (
      guildId: any,
      integrationId: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("deleteGuildIntegration", "guildId", guildId);
      // verify required parameter 'integrationId' is not null or undefined
      assertParamExists("deleteGuildIntegration", "integrationId", integrationId);
      const localVarPath = `/guilds/{guild_id}/integrations/{integration_id}`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"integration_id"}}`, encodeURIComponent(String(integrationId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGuildMember: async (guildId: any, userId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("deleteGuildMember", "guildId", guildId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("deleteGuildMember", "userId", userId);
      const localVarPath = `/guilds/{guild_id}/members/{user_id}`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {any} roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGuildMemberRole: async (
      guildId: any,
      userId: any,
      roleId: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("deleteGuildMemberRole", "guildId", guildId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("deleteGuildMemberRole", "userId", userId);
      // verify required parameter 'roleId' is not null or undefined
      assertParamExists("deleteGuildMemberRole", "roleId", roleId);
      const localVarPath = `/guilds/{guild_id}/members/{user_id}/roles/{role_id}`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
        .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {any} roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGuildRole: async (guildId: any, roleId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("deleteGuildRole", "guildId", guildId);
      // verify required parameter 'roleId' is not null or undefined
      assertParamExists("deleteGuildRole", "roleId", roleId);
      const localVarPath = `/guilds/{guild_id}/roles/{role_id}`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {any} guildScheduledEventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGuildScheduledEvent: async (
      guildId: any,
      guildScheduledEventId: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("deleteGuildScheduledEvent", "guildId", guildId);
      // verify required parameter 'guildScheduledEventId' is not null or undefined
      assertParamExists("deleteGuildScheduledEvent", "guildScheduledEventId", guildScheduledEventId);
      const localVarPath = `/guilds/{guild_id}/scheduled-events/{guild_scheduled_event_id}`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"guild_scheduled_event_id"}}`, encodeURIComponent(String(guildScheduledEventId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {any} stickerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGuildSticker: async (
      guildId: any,
      stickerId: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("deleteGuildSticker", "guildId", guildId);
      // verify required parameter 'stickerId' is not null or undefined
      assertParamExists("deleteGuildSticker", "stickerId", stickerId);
      const localVarPath = `/guilds/{guild_id}/stickers/{sticker_id}`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"sticker_id"}}`, encodeURIComponent(String(stickerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {string} code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGuildTemplate: async (
      guildId: any,
      code: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("deleteGuildTemplate", "guildId", guildId);
      // verify required parameter 'code' is not null or undefined
      assertParamExists("deleteGuildTemplate", "code", code);
      const localVarPath = `/guilds/{guild_id}/templates/{code}`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"code"}}`, encodeURIComponent(String(code)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMessage: async (
      channelId: any,
      messageId: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("deleteMessage", "channelId", channelId);
      // verify required parameter 'messageId' is not null or undefined
      assertParamExists("deleteMessage", "messageId", messageId);
      const localVarPath = `/channels/{channel_id}/messages/{message_id}`
        .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
        .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {string} emojiName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMyMessageReaction: async (
      channelId: any,
      messageId: any,
      emojiName: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("deleteMyMessageReaction", "channelId", channelId);
      // verify required parameter 'messageId' is not null or undefined
      assertParamExists("deleteMyMessageReaction", "messageId", messageId);
      // verify required parameter 'emojiName' is not null or undefined
      assertParamExists("deleteMyMessageReaction", "emojiName", emojiName);
      const localVarPath = `/channels/{channel_id}/messages/{message_id}/reactions/{emoji_name}/@me`
        .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
        .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)))
        .replace(`{${"emoji_name"}}`, encodeURIComponent(String(emojiName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {any} [threadId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOriginalWebhookMessage: async (
      webhookId: any,
      webhookToken: string,
      threadId?: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'webhookId' is not null or undefined
      assertParamExists("deleteOriginalWebhookMessage", "webhookId", webhookId);
      // verify required parameter 'webhookToken' is not null or undefined
      assertParamExists("deleteOriginalWebhookMessage", "webhookToken", webhookToken);
      const localVarPath = `/webhooks/{webhook_id}/{webhook_token}/messages/@original`
        .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)))
        .replace(`{${"webhook_token"}}`, encodeURIComponent(String(webhookToken)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (threadId !== undefined) {
        for (const [key, value] of Object.entries(threadId)) {
          localVarQueryParameter[key] = value;
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteStageInstance: async (channelId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("deleteStageInstance", "channelId", channelId);
      const localVarPath = `/stage-instances/{channel_id}`.replace(
        `{${"channel_id"}}`,
        encodeURIComponent(String(channelId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {any} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteThreadMember: async (
      channelId: any,
      userId: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("deleteThreadMember", "channelId", channelId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("deleteThreadMember", "userId", userId);
      const localVarPath = `/channels/{channel_id}/thread-members/{user_id}`
        .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
        .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {string} emojiName
     * @param {any} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserMessageReaction: async (
      channelId: any,
      messageId: any,
      emojiName: string,
      userId: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("deleteUserMessageReaction", "channelId", channelId);
      // verify required parameter 'messageId' is not null or undefined
      assertParamExists("deleteUserMessageReaction", "messageId", messageId);
      // verify required parameter 'emojiName' is not null or undefined
      assertParamExists("deleteUserMessageReaction", "emojiName", emojiName);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("deleteUserMessageReaction", "userId", userId);
      const localVarPath = `/channels/{channel_id}/messages/{message_id}/reactions/{emoji_name}/{user_id}`
        .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
        .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)))
        .replace(`{${"emoji_name"}}`, encodeURIComponent(String(emojiName)))
        .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhook: async (webhookId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'webhookId' is not null or undefined
      assertParamExists("deleteWebhook", "webhookId", webhookId);
      const localVarPath = `/webhooks/{webhook_id}`.replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhookByToken: async (
      webhookId: any,
      webhookToken: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'webhookId' is not null or undefined
      assertParamExists("deleteWebhookByToken", "webhookId", webhookId);
      // verify required parameter 'webhookToken' is not null or undefined
      assertParamExists("deleteWebhookByToken", "webhookToken", webhookToken);
      const localVarPath = `/webhooks/{webhook_id}/{webhook_token}`
        .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)))
        .replace(`{${"webhook_token"}}`, encodeURIComponent(String(webhookToken)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {any} messageId
     * @param {any} [threadId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhookMessage: async (
      webhookId: any,
      webhookToken: string,
      messageId: any,
      threadId?: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'webhookId' is not null or undefined
      assertParamExists("deleteWebhookMessage", "webhookId", webhookId);
      // verify required parameter 'webhookToken' is not null or undefined
      assertParamExists("deleteWebhookMessage", "webhookToken", webhookToken);
      // verify required parameter 'messageId' is not null or undefined
      assertParamExists("deleteWebhookMessage", "messageId", messageId);
      const localVarPath = `/webhooks/{webhook_id}/{webhook_token}/messages/{message_id}`
        .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)))
        .replace(`{${"webhook_token"}}`, encodeURIComponent(String(webhookToken)))
        .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (threadId !== undefined) {
        for (const [key, value] of Object.entries(threadId)) {
          localVarQueryParameter[key] = value;
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {GithubWebhook} githubWebhook
     * @param {boolean} [wait]
     * @param {any} [threadId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeGithubCompatibleWebhook: async (
      webhookId: any,
      webhookToken: string,
      githubWebhook: GithubWebhook,
      wait?: boolean,
      threadId?: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'webhookId' is not null or undefined
      assertParamExists("executeGithubCompatibleWebhook", "webhookId", webhookId);
      // verify required parameter 'webhookToken' is not null or undefined
      assertParamExists("executeGithubCompatibleWebhook", "webhookToken", webhookToken);
      // verify required parameter 'githubWebhook' is not null or undefined
      assertParamExists("executeGithubCompatibleWebhook", "githubWebhook", githubWebhook);
      const localVarPath = `/webhooks/{webhook_id}/{webhook_token}/github`
        .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)))
        .replace(`{${"webhook_token"}}`, encodeURIComponent(String(webhookToken)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (wait !== undefined) {
        localVarQueryParameter["wait"] = wait;
      }

      if (threadId !== undefined) {
        for (const [key, value] of Object.entries(threadId)) {
          localVarQueryParameter[key] = value;
        }
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(githubWebhook, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {SlackWebhook} slackWebhook
     * @param {boolean} [wait]
     * @param {any} [threadId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeSlackCompatibleWebhook: async (
      webhookId: any,
      webhookToken: string,
      slackWebhook: SlackWebhook,
      wait?: boolean,
      threadId?: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'webhookId' is not null or undefined
      assertParamExists("executeSlackCompatibleWebhook", "webhookId", webhookId);
      // verify required parameter 'webhookToken' is not null or undefined
      assertParamExists("executeSlackCompatibleWebhook", "webhookToken", webhookToken);
      // verify required parameter 'slackWebhook' is not null or undefined
      assertParamExists("executeSlackCompatibleWebhook", "slackWebhook", slackWebhook);
      const localVarPath = `/webhooks/{webhook_id}/{webhook_token}/slack`
        .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)))
        .replace(`{${"webhook_token"}}`, encodeURIComponent(String(webhookToken)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (wait !== undefined) {
        localVarQueryParameter["wait"] = wait;
      }

      if (threadId !== undefined) {
        for (const [key, value] of Object.entries(threadId)) {
          localVarQueryParameter[key] = value;
        }
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(slackWebhook, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {ExecuteWebhookRequest} executeWebhookRequest
     * @param {boolean} [wait]
     * @param {any} [threadId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeWebhook: async (
      webhookId: any,
      webhookToken: string,
      executeWebhookRequest: ExecuteWebhookRequest,
      wait?: boolean,
      threadId?: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'webhookId' is not null or undefined
      assertParamExists("executeWebhook", "webhookId", webhookId);
      // verify required parameter 'webhookToken' is not null or undefined
      assertParamExists("executeWebhook", "webhookToken", webhookToken);
      // verify required parameter 'executeWebhookRequest' is not null or undefined
      assertParamExists("executeWebhook", "executeWebhookRequest", executeWebhookRequest);
      const localVarPath = `/webhooks/{webhook_id}/{webhook_token}`
        .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)))
        .replace(`{${"webhook_token"}}`, encodeURIComponent(String(webhookToken)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (wait !== undefined) {
        localVarQueryParameter["wait"] = wait;
      }

      if (threadId !== undefined) {
        for (const [key, value] of Object.entries(threadId)) {
          localVarQueryParameter[key] = value;
        }
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(executeWebhookRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {FollowChannelRequest} followChannelRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    followChannel: async (
      channelId: any,
      followChannelRequest: FollowChannelRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("followChannel", "channelId", channelId);
      // verify required parameter 'followChannelRequest' is not null or undefined
      assertParamExists("followChannel", "followChannelRequest", followChannelRequest);
      const localVarPath = `/channels/{channel_id}/followers`.replace(
        `{${"channel_id"}}`,
        encodeURIComponent(String(channelId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(followChannelRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActiveGuildThreads: async (guildId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("getActiveGuildThreads", "guildId", guildId);
      const localVarPath = `/guilds/{guild_id}/threads/active`.replace(
        `{${"guild_id"}}`,
        encodeURIComponent(String(guildId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} applicationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplication: async (applicationId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'applicationId' is not null or undefined
      assertParamExists("getApplication", "applicationId", applicationId);
      const localVarPath = `/applications/{application_id}`.replace(
        `{${"application_id"}}`,
        encodeURIComponent(String(applicationId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} commandId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicationCommand: async (
      applicationId: any,
      commandId: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'applicationId' is not null or undefined
      assertParamExists("getApplicationCommand", "applicationId", applicationId);
      // verify required parameter 'commandId' is not null or undefined
      assertParamExists("getApplicationCommand", "commandId", commandId);
      const localVarPath = `/applications/{application_id}/commands/{command_id}`
        .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
        .replace(`{${"command_id"}}`, encodeURIComponent(String(commandId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.update"], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration);

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} applicationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicationRoleConnectionsMetadata: async (
      applicationId: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'applicationId' is not null or undefined
      assertParamExists("getApplicationRoleConnectionsMetadata", "applicationId", applicationId);
      const localVarPath = `/applications/{application_id}/role-connections/metadata`.replace(
        `{${"application_id"}}`,
        encodeURIComponent(String(applicationId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} applicationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicationUserRoleConnection: async (
      applicationId: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'applicationId' is not null or undefined
      assertParamExists("getApplicationUserRoleConnection", "applicationId", applicationId);
      const localVarPath = `/users/@me/applications/{application_id}/role-connection`.replace(
        `{${"application_id"}}`,
        encodeURIComponent(String(applicationId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["role_connections.write"], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {any} ruleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAutoModerationRule: async (
      guildId: any,
      ruleId: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("getAutoModerationRule", "guildId", guildId);
      // verify required parameter 'ruleId' is not null or undefined
      assertParamExists("getAutoModerationRule", "ruleId", ruleId);
      const localVarPath = `/guilds/{guild_id}/auto-moderation/rules/{rule_id}`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBotGateway: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/gateway/bot`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChannel: async (channelId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("getChannel", "channelId", channelId);
      const localVarPath = `/channels/{channel_id}`.replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGateway: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/gateway`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {boolean} [withCounts]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuild: async (guildId: any, withCounts?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("getGuild", "guildId", guildId);
      const localVarPath = `/guilds/{guild_id}`.replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (withCounts !== undefined) {
        localVarQueryParameter["with_counts"] = withCounts;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} guildId
     * @param {any} commandId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildApplicationCommand: async (
      applicationId: any,
      guildId: any,
      commandId: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'applicationId' is not null or undefined
      assertParamExists("getGuildApplicationCommand", "applicationId", applicationId);
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("getGuildApplicationCommand", "guildId", guildId);
      // verify required parameter 'commandId' is not null or undefined
      assertParamExists("getGuildApplicationCommand", "commandId", commandId);
      const localVarPath = `/applications/{application_id}/guilds/{guild_id}/commands/{command_id}`
        .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"command_id"}}`, encodeURIComponent(String(commandId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.update"], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration);

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} guildId
     * @param {any} commandId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildApplicationCommandPermissions: async (
      applicationId: any,
      guildId: any,
      commandId: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'applicationId' is not null or undefined
      assertParamExists("getGuildApplicationCommandPermissions", "applicationId", applicationId);
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("getGuildApplicationCommandPermissions", "guildId", guildId);
      // verify required parameter 'commandId' is not null or undefined
      assertParamExists("getGuildApplicationCommandPermissions", "commandId", commandId);
      const localVarPath = `/applications/{application_id}/guilds/{guild_id}/commands/{command_id}/permissions`
        .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"command_id"}}`, encodeURIComponent(String(commandId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2",
        ["applications.commands.permissions.update"],
        configuration,
      );

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2",
        ["applications.commands.permissions.update"],
        configuration,
      );

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2",
        ["applications.commands.permissions.update"],
        configuration,
      );

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildBan: async (guildId: any, userId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("getGuildBan", "guildId", guildId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("getGuildBan", "userId", userId);
      const localVarPath = `/guilds/{guild_id}/bans/{user_id}`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {any} emojiId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildEmoji: async (guildId: any, emojiId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("getGuildEmoji", "guildId", guildId);
      // verify required parameter 'emojiId' is not null or undefined
      assertParamExists("getGuildEmoji", "emojiId", emojiId);
      const localVarPath = `/guilds/{guild_id}/emojis/{emoji_id}`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"emoji_id"}}`, encodeURIComponent(String(emojiId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildMember: async (guildId: any, userId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("getGuildMember", "guildId", guildId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("getGuildMember", "userId", userId);
      const localVarPath = `/guilds/{guild_id}/members/{user_id}`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildNewMemberWelcome: async (guildId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("getGuildNewMemberWelcome", "guildId", guildId);
      const localVarPath = `/guilds/{guild_id}/new-member-welcome`.replace(
        `{${"guild_id"}}`,
        encodeURIComponent(String(guildId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildPreview: async (guildId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("getGuildPreview", "guildId", guildId);
      const localVarPath = `/guilds/{guild_id}/preview`.replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {any} guildScheduledEventId
     * @param {boolean} [withUserCount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildScheduledEvent: async (
      guildId: any,
      guildScheduledEventId: any,
      withUserCount?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("getGuildScheduledEvent", "guildId", guildId);
      // verify required parameter 'guildScheduledEventId' is not null or undefined
      assertParamExists("getGuildScheduledEvent", "guildScheduledEventId", guildScheduledEventId);
      const localVarPath = `/guilds/{guild_id}/scheduled-events/{guild_scheduled_event_id}`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"guild_scheduled_event_id"}}`, encodeURIComponent(String(guildScheduledEventId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (withUserCount !== undefined) {
        localVarQueryParameter["with_user_count"] = withUserCount;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {any} stickerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildSticker: async (
      guildId: any,
      stickerId: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("getGuildSticker", "guildId", guildId);
      // verify required parameter 'stickerId' is not null or undefined
      assertParamExists("getGuildSticker", "stickerId", stickerId);
      const localVarPath = `/guilds/{guild_id}/stickers/{sticker_id}`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"sticker_id"}}`, encodeURIComponent(String(stickerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildTemplate: async (code: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'code' is not null or undefined
      assertParamExists("getGuildTemplate", "code", code);
      const localVarPath = `/guilds/templates/{code}`.replace(`{${"code"}}`, encodeURIComponent(String(code)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildVanityUrl: async (guildId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("getGuildVanityUrl", "guildId", guildId);
      const localVarPath = `/guilds/{guild_id}/vanity-url`.replace(
        `{${"guild_id"}}`,
        encodeURIComponent(String(guildId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildWebhooks: async (guildId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("getGuildWebhooks", "guildId", guildId);
      const localVarPath = `/guilds/{guild_id}/webhooks`.replace(
        `{${"guild_id"}}`,
        encodeURIComponent(String(guildId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildWelcomeScreen: async (guildId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("getGuildWelcomeScreen", "guildId", guildId);
      const localVarPath = `/guilds/{guild_id}/welcome-screen`.replace(
        `{${"guild_id"}}`,
        encodeURIComponent(String(guildId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildWidget: async (guildId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("getGuildWidget", "guildId", guildId);
      const localVarPath = `/guilds/{guild_id}/widget.json`.replace(
        `{${"guild_id"}}`,
        encodeURIComponent(String(guildId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {WidgetImageStyles} [style]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildWidgetPng: async (
      guildId: any,
      style?: WidgetImageStyles,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("getGuildWidgetPng", "guildId", guildId);
      const localVarPath = `/guilds/{guild_id}/widget.png`.replace(
        `{${"guild_id"}}`,
        encodeURIComponent(String(guildId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (style !== undefined) {
        for (const [key, value] of Object.entries(style)) {
          localVarQueryParameter[key] = value;
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildWidgetSettings: async (guildId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("getGuildWidgetSettings", "guildId", guildId);
      const localVarPath = `/guilds/{guild_id}/widget`.replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildsOnboarding: async (guildId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("getGuildsOnboarding", "guildId", guildId);
      const localVarPath = `/guilds/{guild_id}/onboarding`.replace(
        `{${"guild_id"}}`,
        encodeURIComponent(String(guildId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessage: async (channelId: any, messageId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("getMessage", "channelId", channelId);
      // verify required parameter 'messageId' is not null or undefined
      assertParamExists("getMessage", "messageId", messageId);
      const localVarPath = `/channels/{channel_id}/messages/{message_id}`
        .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
        .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyApplication: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/applications/@me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyGuildMember: async (guildId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("getMyGuildMember", "guildId", guildId);
      const localVarPath = `/users/@me/guilds/{guild_id}/member`.replace(
        `{${"guild_id"}}`,
        encodeURIComponent(String(guildId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["guilds.members.read"], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["guilds.members.read"], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["guilds.members.read"], configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyOauth2Application: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/oauth2/applications/@me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyOauth2Authorization: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/oauth2/@me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2",
        [
          "activities.read",
          "activities.write",
          "applications.builds.read",
          "applications.builds.upload",
          "applications.commands",
          "applications.commands.permissions.update",
          "applications.entitlements",
          "applications.store.update",
          "bot",
          "connections",
          "dm_channels.read",
          "email",
          "gdm.join",
          "guilds",
          "guilds.join",
          "guilds.members.read",
          "identify",
          "messages.read",
          "relationships.read",
          "rpc",
          "rpc.activities.write",
          "rpc.notifications.read",
          "rpc.screenshare.read",
          "rpc.screenshare.write",
          "rpc.video.read",
          "rpc.video.write",
          "rpc.voice.read",
          "rpc.voice.write",
          "voice",
          "webhook.incoming",
        ],
        configuration,
      );

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2",
        [
          "activities.read",
          "activities.write",
          "applications.builds.read",
          "applications.builds.upload",
          "applications.commands",
          "applications.commands.permissions.update",
          "applications.commands.update",
          "applications.entitlements",
          "applications.store.update",
          "bot",
          "connections",
          "dm_channels.read",
          "email",
          "gdm.join",
          "guilds",
          "guilds.join",
          "guilds.members.read",
          "identify",
          "messages.read",
          "relationships.read",
          "rpc",
          "rpc.activities.write",
          "rpc.notifications.read",
          "rpc.screenshare.read",
          "rpc.screenshare.write",
          "rpc.video.read",
          "rpc.video.write",
          "rpc.voice.read",
          "rpc.voice.write",
          "voice",
          "webhook.incoming",
        ],
        configuration,
      );

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2",
        [
          "activities.read",
          "activities.write",
          "applications.builds.read",
          "applications.builds.upload",
          "applications.commands",
          "applications.commands.permissions.update",
          "applications.entitlements",
          "applications.store.update",
          "bot",
          "connections",
          "dm_channels.read",
          "email",
          "gdm.join",
          "guilds",
          "guilds.join",
          "guilds.members.read",
          "identify",
          "messages.read",
          "relationships.read",
          "role_connections.write",
          "rpc",
          "rpc.activities.write",
          "rpc.notifications.read",
          "rpc.screenshare.read",
          "rpc.screenshare.write",
          "rpc.video.read",
          "rpc.video.write",
          "rpc.voice.read",
          "rpc.voice.write",
          "voice",
          "webhook.incoming",
        ],
        configuration,
      );

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/users/@me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["identify"], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["identify"], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["identify"], configuration);

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {any} [threadId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOriginalWebhookMessage: async (
      webhookId: any,
      webhookToken: string,
      threadId?: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'webhookId' is not null or undefined
      assertParamExists("getOriginalWebhookMessage", "webhookId", webhookId);
      // verify required parameter 'webhookToken' is not null or undefined
      assertParamExists("getOriginalWebhookMessage", "webhookToken", webhookToken);
      const localVarPath = `/webhooks/{webhook_id}/{webhook_token}/messages/@original`
        .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)))
        .replace(`{${"webhook_token"}}`, encodeURIComponent(String(webhookToken)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (threadId !== undefined) {
        for (const [key, value] of Object.entries(threadId)) {
          localVarQueryParameter[key] = value;
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStageInstance: async (channelId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("getStageInstance", "channelId", channelId);
      const localVarPath = `/stage-instances/{channel_id}`.replace(
        `{${"channel_id"}}`,
        encodeURIComponent(String(channelId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} stickerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSticker: async (stickerId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'stickerId' is not null or undefined
      assertParamExists("getSticker", "stickerId", stickerId);
      const localVarPath = `/stickers/{sticker_id}`.replace(`{${"sticker_id"}}`, encodeURIComponent(String(stickerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {any} userId
     * @param {boolean} [withMember]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThreadMember: async (
      channelId: any,
      userId: any,
      withMember?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("getThreadMember", "channelId", channelId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("getThreadMember", "userId", userId);
      const localVarPath = `/channels/{channel_id}/thread-members/{user_id}`
        .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
        .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (withMember !== undefined) {
        localVarQueryParameter["with_member"] = withMember;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser: async (userId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("getUser", "userId", userId);
      const localVarPath = `/users/{user_id}`.replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhook: async (webhookId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'webhookId' is not null or undefined
      assertParamExists("getWebhook", "webhookId", webhookId);
      const localVarPath = `/webhooks/{webhook_id}`.replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhookByToken: async (
      webhookId: any,
      webhookToken: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'webhookId' is not null or undefined
      assertParamExists("getWebhookByToken", "webhookId", webhookId);
      // verify required parameter 'webhookToken' is not null or undefined
      assertParamExists("getWebhookByToken", "webhookToken", webhookToken);
      const localVarPath = `/webhooks/{webhook_id}/{webhook_token}`
        .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)))
        .replace(`{${"webhook_token"}}`, encodeURIComponent(String(webhookToken)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {any} messageId
     * @param {any} [threadId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhookMessage: async (
      webhookId: any,
      webhookToken: string,
      messageId: any,
      threadId?: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'webhookId' is not null or undefined
      assertParamExists("getWebhookMessage", "webhookId", webhookId);
      // verify required parameter 'webhookToken' is not null or undefined
      assertParamExists("getWebhookMessage", "webhookToken", webhookToken);
      // verify required parameter 'messageId' is not null or undefined
      assertParamExists("getWebhookMessage", "messageId", messageId);
      const localVarPath = `/webhooks/{webhook_id}/{webhook_token}/messages/{message_id}`
        .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)))
        .replace(`{${"webhook_token"}}`, encodeURIComponent(String(webhookToken)))
        .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (threadId !== undefined) {
        for (const [key, value] of Object.entries(threadId)) {
          localVarQueryParameter[key] = value;
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} code
     * @param {boolean} [withCounts]
     * @param {any} [guildScheduledEventId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    inviteResolve: async (
      code: string,
      withCounts?: boolean,
      guildScheduledEventId?: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'code' is not null or undefined
      assertParamExists("inviteResolve", "code", code);
      const localVarPath = `/invites/{code}`.replace(`{${"code"}}`, encodeURIComponent(String(code)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (withCounts !== undefined) {
        localVarQueryParameter["with_counts"] = withCounts;
      }

      if (guildScheduledEventId !== undefined) {
        for (const [key, value] of Object.entries(guildScheduledEventId)) {
          localVarQueryParameter[key] = value;
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    inviteRevoke: async (code: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'code' is not null or undefined
      assertParamExists("inviteRevoke", "code", code);
      const localVarPath = `/invites/{code}`.replace(`{${"code"}}`, encodeURIComponent(String(code)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    joinThread: async (channelId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("joinThread", "channelId", channelId);
      const localVarPath = `/channels/{channel_id}/thread-members/@me`.replace(
        `{${"channel_id"}}`,
        encodeURIComponent(String(channelId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaveGuild: async (guildId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("leaveGuild", "guildId", guildId);
      const localVarPath = `/users/@me/guilds/{guild_id}`.replace(
        `{${"guild_id"}}`,
        encodeURIComponent(String(guildId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaveThread: async (channelId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("leaveThread", "channelId", channelId);
      const localVarPath = `/channels/{channel_id}/thread-members/@me`.replace(
        `{${"channel_id"}}`,
        encodeURIComponent(String(channelId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} applicationId
     * @param {boolean} [withLocalizations]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listApplicationCommands: async (
      applicationId: any,
      withLocalizations?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'applicationId' is not null or undefined
      assertParamExists("listApplicationCommands", "applicationId", applicationId);
      const localVarPath = `/applications/{application_id}/commands`.replace(
        `{${"application_id"}}`,
        encodeURIComponent(String(applicationId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.update"], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration);

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (withLocalizations !== undefined) {
        localVarQueryParameter["with_localizations"] = withLocalizations;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAutoModerationRules: async (guildId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("listAutoModerationRules", "guildId", guildId);
      const localVarPath = `/guilds/{guild_id}/auto-moderation/rules`.replace(
        `{${"guild_id"}}`,
        encodeURIComponent(String(guildId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listChannelInvites: async (channelId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("listChannelInvites", "channelId", channelId);
      const localVarPath = `/channels/{channel_id}/invites`.replace(
        `{${"channel_id"}}`,
        encodeURIComponent(String(channelId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listChannelWebhooks: async (channelId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("listChannelWebhooks", "channelId", channelId);
      const localVarPath = `/channels/{channel_id}/webhooks`.replace(
        `{${"channel_id"}}`,
        encodeURIComponent(String(channelId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildApplicationCommandPermissions: async (
      applicationId: any,
      guildId: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'applicationId' is not null or undefined
      assertParamExists("listGuildApplicationCommandPermissions", "applicationId", applicationId);
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("listGuildApplicationCommandPermissions", "guildId", guildId);
      const localVarPath = `/applications/{application_id}/guilds/{guild_id}/commands/permissions`
        .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2",
        ["applications.commands.permissions.update"],
        configuration,
      );

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2",
        ["applications.commands.permissions.update"],
        configuration,
      );

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2",
        ["applications.commands.permissions.update"],
        configuration,
      );

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} guildId
     * @param {boolean} [withLocalizations]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildApplicationCommands: async (
      applicationId: any,
      guildId: any,
      withLocalizations?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'applicationId' is not null or undefined
      assertParamExists("listGuildApplicationCommands", "applicationId", applicationId);
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("listGuildApplicationCommands", "guildId", guildId);
      const localVarPath = `/applications/{application_id}/guilds/{guild_id}/commands`
        .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.update"], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration);

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (withLocalizations !== undefined) {
        localVarQueryParameter["with_localizations"] = withLocalizations;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {any} [userId]
     * @param {number} [actionType]
     * @param {any} [before]
     * @param {any} [after]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildAuditLogEntries: async (
      guildId: any,
      userId?: any,
      actionType?: number,
      before?: any,
      after?: any,
      limit?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("listGuildAuditLogEntries", "guildId", guildId);
      const localVarPath = `/guilds/{guild_id}/audit-logs`.replace(
        `{${"guild_id"}}`,
        encodeURIComponent(String(guildId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (userId !== undefined) {
        for (const [key, value] of Object.entries(userId)) {
          localVarQueryParameter[key] = value;
        }
      }

      if (actionType !== undefined) {
        localVarQueryParameter["action_type"] = actionType;
      }

      if (before !== undefined) {
        for (const [key, value] of Object.entries(before)) {
          localVarQueryParameter[key] = value;
        }
      }

      if (after !== undefined) {
        for (const [key, value] of Object.entries(after)) {
          localVarQueryParameter[key] = value;
        }
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {number} [limit]
     * @param {any} [before]
     * @param {any} [after]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildBans: async (
      guildId: any,
      limit?: number,
      before?: any,
      after?: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("listGuildBans", "guildId", guildId);
      const localVarPath = `/guilds/{guild_id}/bans`.replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (before !== undefined) {
        for (const [key, value] of Object.entries(before)) {
          localVarQueryParameter[key] = value;
        }
      }

      if (after !== undefined) {
        for (const [key, value] of Object.entries(after)) {
          localVarQueryParameter[key] = value;
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildChannels: async (guildId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("listGuildChannels", "guildId", guildId);
      const localVarPath = `/guilds/{guild_id}/channels`.replace(
        `{${"guild_id"}}`,
        encodeURIComponent(String(guildId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildEmojis: async (guildId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("listGuildEmojis", "guildId", guildId);
      const localVarPath = `/guilds/{guild_id}/emojis`.replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildIntegrations: async (guildId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("listGuildIntegrations", "guildId", guildId);
      const localVarPath = `/guilds/{guild_id}/integrations`.replace(
        `{${"guild_id"}}`,
        encodeURIComponent(String(guildId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildInvites: async (guildId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("listGuildInvites", "guildId", guildId);
      const localVarPath = `/guilds/{guild_id}/invites`.replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {number} [limit]
     * @param {number} [after]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildMembers: async (
      guildId: any,
      limit?: number,
      after?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("listGuildMembers", "guildId", guildId);
      const localVarPath = `/guilds/{guild_id}/members`.replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (after !== undefined) {
        localVarQueryParameter["after"] = after;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildRoles: async (guildId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("listGuildRoles", "guildId", guildId);
      const localVarPath = `/guilds/{guild_id}/roles`.replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {any} guildScheduledEventId
     * @param {boolean} [withMember]
     * @param {number} [limit]
     * @param {any} [before]
     * @param {any} [after]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildScheduledEventUsers: async (
      guildId: any,
      guildScheduledEventId: any,
      withMember?: boolean,
      limit?: number,
      before?: any,
      after?: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("listGuildScheduledEventUsers", "guildId", guildId);
      // verify required parameter 'guildScheduledEventId' is not null or undefined
      assertParamExists("listGuildScheduledEventUsers", "guildScheduledEventId", guildScheduledEventId);
      const localVarPath = `/guilds/{guild_id}/scheduled-events/{guild_scheduled_event_id}/users`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"guild_scheduled_event_id"}}`, encodeURIComponent(String(guildScheduledEventId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (withMember !== undefined) {
        localVarQueryParameter["with_member"] = withMember;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (before !== undefined) {
        for (const [key, value] of Object.entries(before)) {
          localVarQueryParameter[key] = value;
        }
      }

      if (after !== undefined) {
        for (const [key, value] of Object.entries(after)) {
          localVarQueryParameter[key] = value;
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {boolean} [withUserCount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildScheduledEvents: async (
      guildId: any,
      withUserCount?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("listGuildScheduledEvents", "guildId", guildId);
      const localVarPath = `/guilds/{guild_id}/scheduled-events`.replace(
        `{${"guild_id"}}`,
        encodeURIComponent(String(guildId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (withUserCount !== undefined) {
        localVarQueryParameter["with_user_count"] = withUserCount;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildStickers: async (guildId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("listGuildStickers", "guildId", guildId);
      const localVarPath = `/guilds/{guild_id}/stickers`.replace(
        `{${"guild_id"}}`,
        encodeURIComponent(String(guildId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildTemplates: async (guildId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("listGuildTemplates", "guildId", guildId);
      const localVarPath = `/guilds/{guild_id}/templates`.replace(
        `{${"guild_id"}}`,
        encodeURIComponent(String(guildId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildVoiceRegions: async (guildId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("listGuildVoiceRegions", "guildId", guildId);
      const localVarPath = `/guilds/{guild_id}/regions`.replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {string} emojiName
     * @param {any} [after]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMessageReactionsByEmoji: async (
      channelId: any,
      messageId: any,
      emojiName: string,
      after?: any,
      limit?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("listMessageReactionsByEmoji", "channelId", channelId);
      // verify required parameter 'messageId' is not null or undefined
      assertParamExists("listMessageReactionsByEmoji", "messageId", messageId);
      // verify required parameter 'emojiName' is not null or undefined
      assertParamExists("listMessageReactionsByEmoji", "emojiName", emojiName);
      const localVarPath = `/channels/{channel_id}/messages/{message_id}/reactions/{emoji_name}`
        .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
        .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)))
        .replace(`{${"emoji_name"}}`, encodeURIComponent(String(emojiName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (after !== undefined) {
        for (const [key, value] of Object.entries(after)) {
          localVarQueryParameter[key] = value;
        }
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {any} [around]
     * @param {any} [before]
     * @param {any} [after]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMessages: async (
      channelId: any,
      around?: any,
      before?: any,
      after?: any,
      limit?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("listMessages", "channelId", channelId);
      const localVarPath = `/channels/{channel_id}/messages`.replace(
        `{${"channel_id"}}`,
        encodeURIComponent(String(channelId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (around !== undefined) {
        for (const [key, value] of Object.entries(around)) {
          localVarQueryParameter[key] = value;
        }
      }

      if (before !== undefined) {
        for (const [key, value] of Object.entries(before)) {
          localVarQueryParameter[key] = value;
        }
      }

      if (after !== undefined) {
        for (const [key, value] of Object.entries(after)) {
          localVarQueryParameter[key] = value;
        }
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMyConnections: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/users/@me/connections`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["connections"], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["connections"], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["connections"], configuration);

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} [before]
     * @param {any} [after]
     * @param {number} [limit]
     * @param {boolean} [withCounts]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMyGuilds: async (
      before?: any,
      after?: any,
      limit?: number,
      withCounts?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/@me/guilds`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["guilds"], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["guilds"], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["guilds"], configuration);

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (before !== undefined) {
        for (const [key, value] of Object.entries(before)) {
          localVarQueryParameter[key] = value;
        }
      }

      if (after !== undefined) {
        for (const [key, value] of Object.entries(after)) {
          localVarQueryParameter[key] = value;
        }
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (withCounts !== undefined) {
        localVarQueryParameter["with_counts"] = withCounts;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {any} [before]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMyPrivateArchivedThreads: async (
      channelId: any,
      before?: any,
      limit?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("listMyPrivateArchivedThreads", "channelId", channelId);
      const localVarPath = `/channels/{channel_id}/users/@me/threads/archived/private`.replace(
        `{${"channel_id"}}`,
        encodeURIComponent(String(channelId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (before !== undefined) {
        for (const [key, value] of Object.entries(before)) {
          localVarQueryParameter[key] = value;
        }
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPinnedMessages: async (channelId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("listPinnedMessages", "channelId", channelId);
      const localVarPath = `/channels/{channel_id}/pins`.replace(
        `{${"channel_id"}}`,
        encodeURIComponent(String(channelId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {string} [before]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPrivateArchivedThreads: async (
      channelId: any,
      before?: string,
      limit?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("listPrivateArchivedThreads", "channelId", channelId);
      const localVarPath = `/channels/{channel_id}/threads/archived/private`.replace(
        `{${"channel_id"}}`,
        encodeURIComponent(String(channelId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (before !== undefined) {
        localVarQueryParameter["before"] = (before as any) instanceof Date ? (before as any).toISOString() : before;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {string} [before]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPublicArchivedThreads: async (
      channelId: any,
      before?: string,
      limit?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("listPublicArchivedThreads", "channelId", channelId);
      const localVarPath = `/channels/{channel_id}/threads/archived/public`.replace(
        `{${"channel_id"}}`,
        encodeURIComponent(String(channelId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (before !== undefined) {
        localVarQueryParameter["before"] = (before as any) instanceof Date ? (before as any).toISOString() : before;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listStickerPacks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/sticker-packs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {boolean} [withMember]
     * @param {number} [limit]
     * @param {any} [after]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listThreadMembers: async (
      channelId: any,
      withMember?: boolean,
      limit?: number,
      after?: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("listThreadMembers", "channelId", channelId);
      const localVarPath = `/channels/{channel_id}/thread-members`.replace(
        `{${"channel_id"}}`,
        encodeURIComponent(String(channelId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (withMember !== undefined) {
        localVarQueryParameter["with_member"] = withMember;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (after !== undefined) {
        for (const [key, value] of Object.entries(after)) {
          localVarQueryParameter[key] = value;
        }
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listVoiceRegions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/voice/regions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pinMessage: async (channelId: any, messageId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("pinMessage", "channelId", channelId);
      // verify required parameter 'messageId' is not null or undefined
      assertParamExists("pinMessage", "messageId", messageId);
      const localVarPath = `/channels/{channel_id}/pins/{message_id}`
        .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
        .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {number} [days]
     * @param {string | null} [includeRoles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    previewPruneGuild: async (
      guildId: any,
      days?: number,
      includeRoles?: string | null,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("previewPruneGuild", "guildId", guildId);
      const localVarPath = `/guilds/{guild_id}/prune`.replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (days !== undefined) {
        localVarQueryParameter["days"] = days;
      }

      if (includeRoles !== undefined) {
        localVarQueryParameter["include_roles"] = includeRoles;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {PruneGuildRequest} pruneGuildRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pruneGuild: async (
      guildId: any,
      pruneGuildRequest: PruneGuildRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("pruneGuild", "guildId", guildId);
      // verify required parameter 'pruneGuildRequest' is not null or undefined
      assertParamExists("pruneGuild", "pruneGuildRequest", pruneGuildRequest);
      const localVarPath = `/guilds/{guild_id}/prune`.replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(pruneGuildRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {UpdateGuildOnboardingRequest} updateGuildOnboardingRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putGuildsOnboarding: async (
      guildId: any,
      updateGuildOnboardingRequest: UpdateGuildOnboardingRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("putGuildsOnboarding", "guildId", guildId);
      // verify required parameter 'updateGuildOnboardingRequest' is not null or undefined
      assertParamExists("putGuildsOnboarding", "updateGuildOnboardingRequest", updateGuildOnboardingRequest);
      const localVarPath = `/guilds/{guild_id}/onboarding`.replace(
        `{${"guild_id"}}`,
        encodeURIComponent(String(guildId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateGuildOnboardingRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} limit
     * @param {string} query
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchGuildMembers: async (
      limit: number,
      query: string,
      guildId: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'limit' is not null or undefined
      assertParamExists("searchGuildMembers", "limit", limit);
      // verify required parameter 'query' is not null or undefined
      assertParamExists("searchGuildMembers", "query", query);
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("searchGuildMembers", "guildId", guildId);
      const localVarPath = `/guilds/{guild_id}/members/search`.replace(
        `{${"guild_id"}}`,
        encodeURIComponent(String(guildId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (query !== undefined) {
        localVarQueryParameter["query"] = query;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {any} overwriteId
     * @param {SetChannelPermissionOverwriteRequest} setChannelPermissionOverwriteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setChannelPermissionOverwrite: async (
      channelId: any,
      overwriteId: any,
      setChannelPermissionOverwriteRequest: SetChannelPermissionOverwriteRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("setChannelPermissionOverwrite", "channelId", channelId);
      // verify required parameter 'overwriteId' is not null or undefined
      assertParamExists("setChannelPermissionOverwrite", "overwriteId", overwriteId);
      // verify required parameter 'setChannelPermissionOverwriteRequest' is not null or undefined
      assertParamExists(
        "setChannelPermissionOverwrite",
        "setChannelPermissionOverwriteRequest",
        setChannelPermissionOverwriteRequest,
      );
      const localVarPath = `/channels/{channel_id}/permissions/{overwrite_id}`
        .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
        .replace(`{${"overwrite_id"}}`, encodeURIComponent(String(overwriteId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setChannelPermissionOverwriteRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} guildId
     * @param {any} commandId
     * @param {SetGuildApplicationCommandPermissionsRequest} setGuildApplicationCommandPermissionsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setGuildApplicationCommandPermissions: async (
      applicationId: any,
      guildId: any,
      commandId: any,
      setGuildApplicationCommandPermissionsRequest: SetGuildApplicationCommandPermissionsRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'applicationId' is not null or undefined
      assertParamExists("setGuildApplicationCommandPermissions", "applicationId", applicationId);
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("setGuildApplicationCommandPermissions", "guildId", guildId);
      // verify required parameter 'commandId' is not null or undefined
      assertParamExists("setGuildApplicationCommandPermissions", "commandId", commandId);
      // verify required parameter 'setGuildApplicationCommandPermissionsRequest' is not null or undefined
      assertParamExists(
        "setGuildApplicationCommandPermissions",
        "setGuildApplicationCommandPermissionsRequest",
        setGuildApplicationCommandPermissionsRequest,
      );
      const localVarPath = `/applications/{application_id}/guilds/{guild_id}/commands/{command_id}/permissions`
        .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"command_id"}}`, encodeURIComponent(String(commandId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2",
        ["applications.commands.permissions.update"],
        configuration,
      );

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2",
        ["applications.commands.permissions.update"],
        configuration,
      );

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "OAuth2",
        ["applications.commands.permissions.update"],
        configuration,
      );

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setGuildApplicationCommandPermissionsRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {SetGuildMfaLevelRequest} setGuildMfaLevelRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setGuildMfaLevel: async (
      guildId: any,
      setGuildMfaLevelRequest: SetGuildMfaLevelRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("setGuildMfaLevel", "guildId", guildId);
      // verify required parameter 'setGuildMfaLevelRequest' is not null or undefined
      assertParamExists("setGuildMfaLevel", "setGuildMfaLevelRequest", setGuildMfaLevelRequest);
      const localVarPath = `/guilds/{guild_id}/mfa`.replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setGuildMfaLevelRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {string} code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    syncGuildTemplate: async (
      guildId: any,
      code: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("syncGuildTemplate", "guildId", guildId);
      // verify required parameter 'code' is not null or undefined
      assertParamExists("syncGuildTemplate", "code", code);
      const localVarPath = `/guilds/{guild_id}/templates/{code}`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"code"}}`, encodeURIComponent(String(code)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    triggerTypingIndicator: async (channelId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("triggerTypingIndicator", "channelId", channelId);
      const localVarPath = `/channels/{channel_id}/typing`.replace(
        `{${"channel_id"}}`,
        encodeURIComponent(String(channelId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unbanUserFromGuild: async (
      guildId: any,
      userId: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("unbanUserFromGuild", "guildId", guildId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("unbanUserFromGuild", "userId", userId);
      const localVarPath = `/guilds/{guild_id}/bans/{user_id}`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unpinMessage: async (channelId: any, messageId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("unpinMessage", "channelId", channelId);
      // verify required parameter 'messageId' is not null or undefined
      assertParamExists("unpinMessage", "messageId", messageId);
      const localVarPath = `/channels/{channel_id}/pins/{message_id}`
        .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
        .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} applicationId
     * @param {ApplicationFormPartial} applicationFormPartial
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateApplication: async (
      applicationId: any,
      applicationFormPartial: ApplicationFormPartial,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'applicationId' is not null or undefined
      assertParamExists("updateApplication", "applicationId", applicationId);
      // verify required parameter 'applicationFormPartial' is not null or undefined
      assertParamExists("updateApplication", "applicationFormPartial", applicationFormPartial);
      const localVarPath = `/applications/{application_id}`.replace(
        `{${"application_id"}}`,
        encodeURIComponent(String(applicationId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        applicationFormPartial,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} commandId
     * @param {ApplicationCommandPatchRequestPartial} applicationCommandPatchRequestPartial
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateApplicationCommand: async (
      applicationId: any,
      commandId: any,
      applicationCommandPatchRequestPartial: ApplicationCommandPatchRequestPartial,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'applicationId' is not null or undefined
      assertParamExists("updateApplicationCommand", "applicationId", applicationId);
      // verify required parameter 'commandId' is not null or undefined
      assertParamExists("updateApplicationCommand", "commandId", commandId);
      // verify required parameter 'applicationCommandPatchRequestPartial' is not null or undefined
      assertParamExists(
        "updateApplicationCommand",
        "applicationCommandPatchRequestPartial",
        applicationCommandPatchRequestPartial,
      );
      const localVarPath = `/applications/{application_id}/commands/{command_id}`
        .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
        .replace(`{${"command_id"}}`, encodeURIComponent(String(commandId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.update"], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration);

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        applicationCommandPatchRequestPartial,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} applicationId
     * @param {Array<ApplicationRoleConnectionsMetadataItemRequest>} applicationRoleConnectionsMetadataItemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateApplicationRoleConnectionsMetadata: async (
      applicationId: any,
      applicationRoleConnectionsMetadataItemRequest: Array<ApplicationRoleConnectionsMetadataItemRequest>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'applicationId' is not null or undefined
      assertParamExists("updateApplicationRoleConnectionsMetadata", "applicationId", applicationId);
      // verify required parameter 'applicationRoleConnectionsMetadataItemRequest' is not null or undefined
      assertParamExists(
        "updateApplicationRoleConnectionsMetadata",
        "applicationRoleConnectionsMetadataItemRequest",
        applicationRoleConnectionsMetadataItemRequest,
      );
      const localVarPath = `/applications/{application_id}/role-connections/metadata`.replace(
        `{${"application_id"}}`,
        encodeURIComponent(String(applicationId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        applicationRoleConnectionsMetadataItemRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} applicationId
     * @param {UpdateApplicationUserRoleConnectionRequest} updateApplicationUserRoleConnectionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateApplicationUserRoleConnection: async (
      applicationId: any,
      updateApplicationUserRoleConnectionRequest: UpdateApplicationUserRoleConnectionRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'applicationId' is not null or undefined
      assertParamExists("updateApplicationUserRoleConnection", "applicationId", applicationId);
      // verify required parameter 'updateApplicationUserRoleConnectionRequest' is not null or undefined
      assertParamExists(
        "updateApplicationUserRoleConnection",
        "updateApplicationUserRoleConnectionRequest",
        updateApplicationUserRoleConnectionRequest,
      );
      const localVarPath = `/users/@me/applications/{application_id}/role-connection`.replace(
        `{${"application_id"}}`,
        encodeURIComponent(String(applicationId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["role_connections.write"], configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateApplicationUserRoleConnectionRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {any} ruleId
     * @param {UpdateAutoModerationRuleRequest} updateAutoModerationRuleRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAutoModerationRule: async (
      guildId: any,
      ruleId: any,
      updateAutoModerationRuleRequest: UpdateAutoModerationRuleRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("updateAutoModerationRule", "guildId", guildId);
      // verify required parameter 'ruleId' is not null or undefined
      assertParamExists("updateAutoModerationRule", "ruleId", ruleId);
      // verify required parameter 'updateAutoModerationRuleRequest' is not null or undefined
      assertParamExists("updateAutoModerationRule", "updateAutoModerationRuleRequest", updateAutoModerationRuleRequest);
      const localVarPath = `/guilds/{guild_id}/auto-moderation/rules/{rule_id}`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateAutoModerationRuleRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {UpdateChannelRequest} updateChannelRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateChannel: async (
      channelId: any,
      updateChannelRequest: UpdateChannelRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("updateChannel", "channelId", channelId);
      // verify required parameter 'updateChannelRequest' is not null or undefined
      assertParamExists("updateChannel", "updateChannelRequest", updateChannelRequest);
      const localVarPath = `/channels/{channel_id}`.replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(updateChannelRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {GuildPatchRequestPartial} guildPatchRequestPartial
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGuild: async (
      guildId: any,
      guildPatchRequestPartial: GuildPatchRequestPartial,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("updateGuild", "guildId", guildId);
      // verify required parameter 'guildPatchRequestPartial' is not null or undefined
      assertParamExists("updateGuild", "guildPatchRequestPartial", guildPatchRequestPartial);
      const localVarPath = `/guilds/{guild_id}`.replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        guildPatchRequestPartial,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} guildId
     * @param {any} commandId
     * @param {ApplicationCommandPatchRequestPartial} applicationCommandPatchRequestPartial
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGuildApplicationCommand: async (
      applicationId: any,
      guildId: any,
      commandId: any,
      applicationCommandPatchRequestPartial: ApplicationCommandPatchRequestPartial,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'applicationId' is not null or undefined
      assertParamExists("updateGuildApplicationCommand", "applicationId", applicationId);
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("updateGuildApplicationCommand", "guildId", guildId);
      // verify required parameter 'commandId' is not null or undefined
      assertParamExists("updateGuildApplicationCommand", "commandId", commandId);
      // verify required parameter 'applicationCommandPatchRequestPartial' is not null or undefined
      assertParamExists(
        "updateGuildApplicationCommand",
        "applicationCommandPatchRequestPartial",
        applicationCommandPatchRequestPartial,
      );
      const localVarPath = `/applications/{application_id}/guilds/{guild_id}/commands/{command_id}`
        .replace(`{${"application_id"}}`, encodeURIComponent(String(applicationId)))
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"command_id"}}`, encodeURIComponent(String(commandId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", ["applications.commands.update"], configuration);

      // authentication OAuth2 required
      // oauth required
      await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration);

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        applicationCommandPatchRequestPartial,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {any} emojiId
     * @param {UpdateGuildEmojiRequest} updateGuildEmojiRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGuildEmoji: async (
      guildId: any,
      emojiId: any,
      updateGuildEmojiRequest: UpdateGuildEmojiRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("updateGuildEmoji", "guildId", guildId);
      // verify required parameter 'emojiId' is not null or undefined
      assertParamExists("updateGuildEmoji", "emojiId", emojiId);
      // verify required parameter 'updateGuildEmojiRequest' is not null or undefined
      assertParamExists("updateGuildEmoji", "updateGuildEmojiRequest", updateGuildEmojiRequest);
      const localVarPath = `/guilds/{guild_id}/emojis/{emoji_id}`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"emoji_id"}}`, encodeURIComponent(String(emojiId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateGuildEmojiRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {UpdateGuildMemberRequest} updateGuildMemberRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGuildMember: async (
      guildId: any,
      userId: any,
      updateGuildMemberRequest: UpdateGuildMemberRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("updateGuildMember", "guildId", guildId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("updateGuildMember", "userId", userId);
      // verify required parameter 'updateGuildMemberRequest' is not null or undefined
      assertParamExists("updateGuildMember", "updateGuildMemberRequest", updateGuildMemberRequest);
      const localVarPath = `/guilds/{guild_id}/members/{user_id}`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateGuildMemberRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {any} roleId
     * @param {UpdateGuildRoleRequest} updateGuildRoleRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGuildRole: async (
      guildId: any,
      roleId: any,
      updateGuildRoleRequest: UpdateGuildRoleRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("updateGuildRole", "guildId", guildId);
      // verify required parameter 'roleId' is not null or undefined
      assertParamExists("updateGuildRole", "roleId", roleId);
      // verify required parameter 'updateGuildRoleRequest' is not null or undefined
      assertParamExists("updateGuildRole", "updateGuildRoleRequest", updateGuildRoleRequest);
      const localVarPath = `/guilds/{guild_id}/roles/{role_id}`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateGuildRoleRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {any} guildScheduledEventId
     * @param {UpdateGuildScheduledEventRequest} updateGuildScheduledEventRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGuildScheduledEvent: async (
      guildId: any,
      guildScheduledEventId: any,
      updateGuildScheduledEventRequest: UpdateGuildScheduledEventRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("updateGuildScheduledEvent", "guildId", guildId);
      // verify required parameter 'guildScheduledEventId' is not null or undefined
      assertParamExists("updateGuildScheduledEvent", "guildScheduledEventId", guildScheduledEventId);
      // verify required parameter 'updateGuildScheduledEventRequest' is not null or undefined
      assertParamExists(
        "updateGuildScheduledEvent",
        "updateGuildScheduledEventRequest",
        updateGuildScheduledEventRequest,
      );
      const localVarPath = `/guilds/{guild_id}/scheduled-events/{guild_scheduled_event_id}`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"guild_scheduled_event_id"}}`, encodeURIComponent(String(guildScheduledEventId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateGuildScheduledEventRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {any} stickerId
     * @param {UpdateGuildStickerRequest} updateGuildStickerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGuildSticker: async (
      guildId: any,
      stickerId: any,
      updateGuildStickerRequest: UpdateGuildStickerRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("updateGuildSticker", "guildId", guildId);
      // verify required parameter 'stickerId' is not null or undefined
      assertParamExists("updateGuildSticker", "stickerId", stickerId);
      // verify required parameter 'updateGuildStickerRequest' is not null or undefined
      assertParamExists("updateGuildSticker", "updateGuildStickerRequest", updateGuildStickerRequest);
      const localVarPath = `/guilds/{guild_id}/stickers/{sticker_id}`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"sticker_id"}}`, encodeURIComponent(String(stickerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateGuildStickerRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {string} code
     * @param {UpdateGuildTemplateRequest} updateGuildTemplateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGuildTemplate: async (
      guildId: any,
      code: string,
      updateGuildTemplateRequest: UpdateGuildTemplateRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("updateGuildTemplate", "guildId", guildId);
      // verify required parameter 'code' is not null or undefined
      assertParamExists("updateGuildTemplate", "code", code);
      // verify required parameter 'updateGuildTemplateRequest' is not null or undefined
      assertParamExists("updateGuildTemplate", "updateGuildTemplateRequest", updateGuildTemplateRequest);
      const localVarPath = `/guilds/{guild_id}/templates/{code}`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"code"}}`, encodeURIComponent(String(code)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateGuildTemplateRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {WelcomeScreenPatchRequestPartial} welcomeScreenPatchRequestPartial
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGuildWelcomeScreen: async (
      guildId: any,
      welcomeScreenPatchRequestPartial: WelcomeScreenPatchRequestPartial,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("updateGuildWelcomeScreen", "guildId", guildId);
      // verify required parameter 'welcomeScreenPatchRequestPartial' is not null or undefined
      assertParamExists(
        "updateGuildWelcomeScreen",
        "welcomeScreenPatchRequestPartial",
        welcomeScreenPatchRequestPartial,
      );
      const localVarPath = `/guilds/{guild_id}/welcome-screen`.replace(
        `{${"guild_id"}}`,
        encodeURIComponent(String(guildId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        welcomeScreenPatchRequestPartial,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {UpdateGuildWidgetSettingsRequest} updateGuildWidgetSettingsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGuildWidgetSettings: async (
      guildId: any,
      updateGuildWidgetSettingsRequest: UpdateGuildWidgetSettingsRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("updateGuildWidgetSettings", "guildId", guildId);
      // verify required parameter 'updateGuildWidgetSettingsRequest' is not null or undefined
      assertParamExists(
        "updateGuildWidgetSettings",
        "updateGuildWidgetSettingsRequest",
        updateGuildWidgetSettingsRequest,
      );
      const localVarPath = `/guilds/{guild_id}/widget`.replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateGuildWidgetSettingsRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {MessageEditRequestPartial} messageEditRequestPartial
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMessage: async (
      channelId: any,
      messageId: any,
      messageEditRequestPartial: MessageEditRequestPartial,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("updateMessage", "channelId", channelId);
      // verify required parameter 'messageId' is not null or undefined
      assertParamExists("updateMessage", "messageId", messageId);
      // verify required parameter 'messageEditRequestPartial' is not null or undefined
      assertParamExists("updateMessage", "messageEditRequestPartial", messageEditRequestPartial);
      const localVarPath = `/channels/{channel_id}/messages/{message_id}`
        .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId)))
        .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        messageEditRequestPartial,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {ApplicationFormPartial} applicationFormPartial
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMyApplication: async (
      applicationFormPartial: ApplicationFormPartial,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'applicationFormPartial' is not null or undefined
      assertParamExists("updateMyApplication", "applicationFormPartial", applicationFormPartial);
      const localVarPath = `/applications/@me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        applicationFormPartial,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {UpdateMyGuildMemberRequest} updateMyGuildMemberRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMyGuildMember: async (
      guildId: any,
      updateMyGuildMemberRequest: UpdateMyGuildMemberRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("updateMyGuildMember", "guildId", guildId);
      // verify required parameter 'updateMyGuildMemberRequest' is not null or undefined
      assertParamExists("updateMyGuildMember", "updateMyGuildMemberRequest", updateMyGuildMemberRequest);
      const localVarPath = `/guilds/{guild_id}/members/@me`.replace(
        `{${"guild_id"}}`,
        encodeURIComponent(String(guildId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateMyGuildMemberRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {BotAccountPatchRequest} botAccountPatchRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMyUser: async (
      botAccountPatchRequest: BotAccountPatchRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'botAccountPatchRequest' is not null or undefined
      assertParamExists("updateMyUser", "botAccountPatchRequest", botAccountPatchRequest);
      const localVarPath = `/users/@me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        botAccountPatchRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {IncomingWebhookUpdateRequestPartial} incomingWebhookUpdateRequestPartial
     * @param {any} [threadId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateOriginalWebhookMessage: async (
      webhookId: any,
      webhookToken: string,
      incomingWebhookUpdateRequestPartial: IncomingWebhookUpdateRequestPartial,
      threadId?: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'webhookId' is not null or undefined
      assertParamExists("updateOriginalWebhookMessage", "webhookId", webhookId);
      // verify required parameter 'webhookToken' is not null or undefined
      assertParamExists("updateOriginalWebhookMessage", "webhookToken", webhookToken);
      // verify required parameter 'incomingWebhookUpdateRequestPartial' is not null or undefined
      assertParamExists(
        "updateOriginalWebhookMessage",
        "incomingWebhookUpdateRequestPartial",
        incomingWebhookUpdateRequestPartial,
      );
      const localVarPath = `/webhooks/{webhook_id}/{webhook_token}/messages/@original`
        .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)))
        .replace(`{${"webhook_token"}}`, encodeURIComponent(String(webhookToken)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (threadId !== undefined) {
        for (const [key, value] of Object.entries(threadId)) {
          localVarQueryParameter[key] = value;
        }
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        incomingWebhookUpdateRequestPartial,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {UpdateSelfVoiceStateRequest} updateSelfVoiceStateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSelfVoiceState: async (
      guildId: any,
      updateSelfVoiceStateRequest: UpdateSelfVoiceStateRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("updateSelfVoiceState", "guildId", guildId);
      // verify required parameter 'updateSelfVoiceStateRequest' is not null or undefined
      assertParamExists("updateSelfVoiceState", "updateSelfVoiceStateRequest", updateSelfVoiceStateRequest);
      const localVarPath = `/guilds/{guild_id}/voice-states/@me`.replace(
        `{${"guild_id"}}`,
        encodeURIComponent(String(guildId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateSelfVoiceStateRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} channelId
     * @param {UpdateStageInstanceRequest} updateStageInstanceRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStageInstance: async (
      channelId: any,
      updateStageInstanceRequest: UpdateStageInstanceRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'channelId' is not null or undefined
      assertParamExists("updateStageInstance", "channelId", channelId);
      // verify required parameter 'updateStageInstanceRequest' is not null or undefined
      assertParamExists("updateStageInstance", "updateStageInstanceRequest", updateStageInstanceRequest);
      const localVarPath = `/stage-instances/{channel_id}`.replace(
        `{${"channel_id"}}`,
        encodeURIComponent(String(channelId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateStageInstanceRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {UpdateVoiceStateRequest} updateVoiceStateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateVoiceState: async (
      guildId: any,
      userId: any,
      updateVoiceStateRequest: UpdateVoiceStateRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'guildId' is not null or undefined
      assertParamExists("updateVoiceState", "guildId", guildId);
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("updateVoiceState", "userId", userId);
      // verify required parameter 'updateVoiceStateRequest' is not null or undefined
      assertParamExists("updateVoiceState", "updateVoiceStateRequest", updateVoiceStateRequest);
      const localVarPath = `/guilds/{guild_id}/voice-states/{user_id}`
        .replace(`{${"guild_id"}}`, encodeURIComponent(String(guildId)))
        .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateVoiceStateRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} webhookId
     * @param {UpdateWebhookRequest} updateWebhookRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWebhook: async (
      webhookId: any,
      updateWebhookRequest: UpdateWebhookRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'webhookId' is not null or undefined
      assertParamExists("updateWebhook", "webhookId", webhookId);
      // verify required parameter 'updateWebhookRequest' is not null or undefined
      assertParamExists("updateWebhook", "updateWebhookRequest", updateWebhookRequest);
      const localVarPath = `/webhooks/{webhook_id}`.replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(updateWebhookRequest, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {UpdateWebhookByTokenRequest} updateWebhookByTokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWebhookByToken: async (
      webhookId: any,
      webhookToken: string,
      updateWebhookByTokenRequest: UpdateWebhookByTokenRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'webhookId' is not null or undefined
      assertParamExists("updateWebhookByToken", "webhookId", webhookId);
      // verify required parameter 'webhookToken' is not null or undefined
      assertParamExists("updateWebhookByToken", "webhookToken", webhookToken);
      // verify required parameter 'updateWebhookByTokenRequest' is not null or undefined
      assertParamExists("updateWebhookByToken", "updateWebhookByTokenRequest", updateWebhookByTokenRequest);
      const localVarPath = `/webhooks/{webhook_id}/{webhook_token}`
        .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)))
        .replace(`{${"webhook_token"}}`, encodeURIComponent(String(webhookToken)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateWebhookByTokenRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {any} messageId
     * @param {IncomingWebhookUpdateRequestPartial} incomingWebhookUpdateRequestPartial
     * @param {any} [threadId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWebhookMessage: async (
      webhookId: any,
      webhookToken: string,
      messageId: any,
      incomingWebhookUpdateRequestPartial: IncomingWebhookUpdateRequestPartial,
      threadId?: any,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'webhookId' is not null or undefined
      assertParamExists("updateWebhookMessage", "webhookId", webhookId);
      // verify required parameter 'webhookToken' is not null or undefined
      assertParamExists("updateWebhookMessage", "webhookToken", webhookToken);
      // verify required parameter 'messageId' is not null or undefined
      assertParamExists("updateWebhookMessage", "messageId", messageId);
      // verify required parameter 'incomingWebhookUpdateRequestPartial' is not null or undefined
      assertParamExists(
        "updateWebhookMessage",
        "incomingWebhookUpdateRequestPartial",
        incomingWebhookUpdateRequestPartial,
      );
      const localVarPath = `/webhooks/{webhook_id}/{webhook_token}/messages/{message_id}`
        .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)))
        .replace(`{${"webhook_token"}}`, encodeURIComponent(String(webhookToken)))
        .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication BotToken required
      await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);

      if (threadId !== undefined) {
        for (const [key, value] of Object.entries(threadId)) {
          localVarQueryParameter[key] = value;
        }
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        incomingWebhookUpdateRequestPartial,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {any} channelId
     * @param {any} userId
     * @param {AddGroupDmUserRequest} addGroupDmUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addGroupDmUser(
      channelId: any,
      userId: any,
      addGroupDmUserRequest: AddGroupDmUserRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDm200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addGroupDmUser(
        channelId,
        userId,
        addGroupDmUserRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.addGroupDmUser"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {AddGuildMemberRequest} addGuildMemberRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addGuildMember(
      guildId: any,
      userId: any,
      addGuildMemberRequest: AddGuildMemberRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildMemberResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addGuildMember(
        guildId,
        userId,
        addGuildMemberRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.addGuildMember"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {any} roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addGuildMemberRole(
      guildId: any,
      userId: any,
      roleId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addGuildMemberRole(guildId, userId, roleId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.addGuildMemberRole"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {string} emojiName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addMyMessageReaction(
      channelId: any,
      messageId: any,
      emojiName: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addMyMessageReaction(
        channelId,
        messageId,
        emojiName,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.addMyMessageReaction"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {any} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addThreadMember(
      channelId: any,
      userId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addThreadMember(channelId, userId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.addThreadMember"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {BanUserFromGuildRequest} banUserFromGuildRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async banUserFromGuild(
      guildId: any,
      userId: any,
      banUserFromGuildRequest: BanUserFromGuildRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.banUserFromGuild(
        guildId,
        userId,
        banUserFromGuildRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.banUserFromGuild"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {BulkDeleteMessagesRequest} bulkDeleteMessagesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkDeleteMessages(
      channelId: any,
      bulkDeleteMessagesRequest: BulkDeleteMessagesRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkDeleteMessages(
        channelId,
        bulkDeleteMessagesRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.bulkDeleteMessages"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} applicationId
     * @param {Array<ApplicationCommandUpdateRequest>} applicationCommandUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkSetApplicationCommands(
      applicationId: any,
      applicationCommandUpdateRequest: Array<ApplicationCommandUpdateRequest>,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationCommandResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkSetApplicationCommands(
        applicationId,
        applicationCommandUpdateRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.bulkSetApplicationCommands"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} guildId
     * @param {Array<ApplicationCommandUpdateRequest>} applicationCommandUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkSetGuildApplicationCommands(
      applicationId: any,
      guildId: any,
      applicationCommandUpdateRequest: Array<ApplicationCommandUpdateRequest>,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationCommandResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkSetGuildApplicationCommands(
        applicationId,
        guildId,
        applicationCommandUpdateRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.bulkSetGuildApplicationCommands"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {Array<BulkUpdateGuildChannelsRequestInner>} bulkUpdateGuildChannelsRequestInner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkUpdateGuildChannels(
      guildId: any,
      bulkUpdateGuildChannelsRequestInner: Array<BulkUpdateGuildChannelsRequestInner>,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkUpdateGuildChannels(
        guildId,
        bulkUpdateGuildChannelsRequestInner,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.bulkUpdateGuildChannels"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {Array<BulkUpdateGuildRolesRequestInner>} bulkUpdateGuildRolesRequestInner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkUpdateGuildRoles(
      guildId: any,
      bulkUpdateGuildRolesRequestInner: Array<BulkUpdateGuildRolesRequestInner>,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GuildRoleResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkUpdateGuildRoles(
        guildId,
        bulkUpdateGuildRolesRequestInner,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.bulkUpdateGuildRoles"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} applicationId
     * @param {ApplicationCommandCreateRequest} applicationCommandCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createApplicationCommand(
      applicationId: any,
      applicationCommandCreateRequest: ApplicationCommandCreateRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationCommandResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicationCommand(
        applicationId,
        applicationCommandCreateRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.createApplicationCommand"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {CreateAutoModerationRuleRequest} createAutoModerationRuleRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAutoModerationRule(
      guildId: any,
      createAutoModerationRuleRequest: CreateAutoModerationRuleRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAutoModerationRule200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createAutoModerationRule(
        guildId,
        createAutoModerationRuleRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.createAutoModerationRule"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {CreateChannelInviteRequest} createChannelInviteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createChannelInvite(
      channelId: any,
      createChannelInviteRequest: CreateChannelInviteRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListChannelInvites200ResponseInner>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createChannelInvite(
        channelId,
        createChannelInviteRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.createChannelInvite"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {CreatePrivateChannelRequest} createPrivateChannelRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createDm(
      createPrivateChannelRequest: CreatePrivateChannelRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDm200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createDm(createPrivateChannelRequest, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.createDm"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {GuildCreateRequest} guildCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createGuild(
      guildCreateRequest: GuildCreateRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createGuild(guildCreateRequest, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.createGuild"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} guildId
     * @param {ApplicationCommandCreateRequest} applicationCommandCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createGuildApplicationCommand(
      applicationId: any,
      guildId: any,
      applicationCommandCreateRequest: ApplicationCommandCreateRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationCommandResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createGuildApplicationCommand(
        applicationId,
        guildId,
        applicationCommandCreateRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.createGuildApplicationCommand"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {CreateGuildChannelRequest} createGuildChannelRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createGuildChannel(
      guildId: any,
      createGuildChannelRequest: CreateGuildChannelRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildChannelResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createGuildChannel(
        guildId,
        createGuildChannelRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.createGuildChannel"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {CreateGuildEmojiRequest} createGuildEmojiRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createGuildEmoji(
      guildId: any,
      createGuildEmojiRequest: CreateGuildEmojiRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmojiResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createGuildEmoji(
        guildId,
        createGuildEmojiRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.createGuildEmoji"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {string} code
     * @param {CreateGuildFromTemplateRequest} createGuildFromTemplateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createGuildFromTemplate(
      code: string,
      createGuildFromTemplateRequest: CreateGuildFromTemplateRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createGuildFromTemplate(
        code,
        createGuildFromTemplateRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.createGuildFromTemplate"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {UpdateGuildRoleRequest} updateGuildRoleRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createGuildRole(
      guildId: any,
      updateGuildRoleRequest: UpdateGuildRoleRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildRoleResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createGuildRole(
        guildId,
        updateGuildRoleRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.createGuildRole"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {CreateGuildScheduledEventRequest} createGuildScheduledEventRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createGuildScheduledEvent(
      guildId: any,
      createGuildScheduledEventRequest: CreateGuildScheduledEventRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGuildScheduledEvent200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createGuildScheduledEvent(
        guildId,
        createGuildScheduledEventRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.createGuildScheduledEvent"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {string} name
     * @param {string} tags
     * @param {string} file
     * @param {string | null} [description]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createGuildSticker(
      guildId: any,
      name: string,
      tags: string,
      file: string,
      description?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildStickerResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createGuildSticker(
        guildId,
        name,
        tags,
        file,
        description,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.createGuildSticker"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {CreateGuildTemplateRequest} createGuildTemplateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createGuildTemplate(
      guildId: any,
      createGuildTemplateRequest: CreateGuildTemplateRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildTemplateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createGuildTemplate(
        guildId,
        createGuildTemplateRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.createGuildTemplate"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} interactionId
     * @param {string} interactionToken
     * @param {CreateInteractionResponseRequest} createInteractionResponseRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createInteractionResponse(
      interactionId: any,
      interactionToken: string,
      createInteractionResponseRequest: CreateInteractionResponseRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createInteractionResponse(
        interactionId,
        interactionToken,
        createInteractionResponseRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.createInteractionResponse"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {MessageCreateRequest} messageCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createMessage(
      channelId: any,
      messageCreateRequest: MessageCreateRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createMessage(channelId, messageCreateRequest, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.createMessage"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {CreateStageInstanceRequest} createStageInstanceRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createStageInstance(
      createStageInstanceRequest: CreateStageInstanceRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StageInstanceResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createStageInstance(
        createStageInstanceRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.createStageInstance"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {CreateThreadRequest} createThreadRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createThread(
      channelId: any,
      createThreadRequest: CreateThreadRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatedThreadResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createThread(channelId, createThreadRequest, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.createThread"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {CreateTextThreadWithMessageRequest} createTextThreadWithMessageRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createThreadFromMessage(
      channelId: any,
      messageId: any,
      createTextThreadWithMessageRequest: CreateTextThreadWithMessageRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createThreadFromMessage(
        channelId,
        messageId,
        createTextThreadWithMessageRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.createThreadFromMessage"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {CreateWebhookRequest} createWebhookRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createWebhook(
      channelId: any,
      createWebhookRequest: CreateWebhookRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildIncomingWebhookResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createWebhook(channelId, createWebhookRequest, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.createWebhook"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async crosspostMessage(
      channelId: any,
      messageId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.crosspostMessage(channelId, messageId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.crosspostMessage"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAllMessageReactions(
      channelId: any,
      messageId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllMessageReactions(
        channelId,
        messageId,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.deleteAllMessageReactions"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {string} emojiName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAllMessageReactionsByEmoji(
      channelId: any,
      messageId: any,
      emojiName: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllMessageReactionsByEmoji(
        channelId,
        messageId,
        emojiName,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.deleteAllMessageReactionsByEmoji"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} commandId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteApplicationCommand(
      applicationId: any,
      commandId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicationCommand(
        applicationId,
        commandId,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.deleteApplicationCommand"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {any} ruleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAutoModerationRule(
      guildId: any,
      ruleId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAutoModerationRule(guildId, ruleId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.deleteAutoModerationRule"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteChannel(
      channelId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListGuildChannels200ResponseInner>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteChannel(channelId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.deleteChannel"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {any} overwriteId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteChannelPermissionOverwrite(
      channelId: any,
      overwriteId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteChannelPermissionOverwrite(
        channelId,
        overwriteId,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.deleteChannelPermissionOverwrite"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {any} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteGroupDmUser(
      channelId: any,
      userId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroupDmUser(channelId, userId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.deleteGroupDmUser"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteGuild(
      guildId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGuild(guildId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.deleteGuild"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} guildId
     * @param {any} commandId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteGuildApplicationCommand(
      applicationId: any,
      guildId: any,
      commandId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGuildApplicationCommand(
        applicationId,
        guildId,
        commandId,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.deleteGuildApplicationCommand"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {any} emojiId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteGuildEmoji(
      guildId: any,
      emojiId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGuildEmoji(guildId, emojiId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.deleteGuildEmoji"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {any} integrationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteGuildIntegration(
      guildId: any,
      integrationId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGuildIntegration(guildId, integrationId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.deleteGuildIntegration"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteGuildMember(
      guildId: any,
      userId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGuildMember(guildId, userId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.deleteGuildMember"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {any} roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteGuildMemberRole(
      guildId: any,
      userId: any,
      roleId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGuildMemberRole(guildId, userId, roleId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.deleteGuildMemberRole"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {any} roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteGuildRole(
      guildId: any,
      roleId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGuildRole(guildId, roleId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.deleteGuildRole"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {any} guildScheduledEventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteGuildScheduledEvent(
      guildId: any,
      guildScheduledEventId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGuildScheduledEvent(
        guildId,
        guildScheduledEventId,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.deleteGuildScheduledEvent"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {any} stickerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteGuildSticker(
      guildId: any,
      stickerId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGuildSticker(guildId, stickerId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.deleteGuildSticker"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {string} code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteGuildTemplate(
      guildId: any,
      code: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildTemplateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGuildTemplate(guildId, code, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.deleteGuildTemplate"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteMessage(
      channelId: any,
      messageId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMessage(channelId, messageId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.deleteMessage"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {string} emojiName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteMyMessageReaction(
      channelId: any,
      messageId: any,
      emojiName: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMyMessageReaction(
        channelId,
        messageId,
        emojiName,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.deleteMyMessageReaction"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {any} [threadId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteOriginalWebhookMessage(
      webhookId: any,
      webhookToken: string,
      threadId?: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOriginalWebhookMessage(
        webhookId,
        webhookToken,
        threadId,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.deleteOriginalWebhookMessage"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteStageInstance(
      channelId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStageInstance(channelId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.deleteStageInstance"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {any} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteThreadMember(
      channelId: any,
      userId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteThreadMember(channelId, userId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.deleteThreadMember"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {string} emojiName
     * @param {any} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUserMessageReaction(
      channelId: any,
      messageId: any,
      emojiName: string,
      userId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserMessageReaction(
        channelId,
        messageId,
        emojiName,
        userId,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.deleteUserMessageReaction"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteWebhook(
      webhookId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(webhookId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.deleteWebhook"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteWebhookByToken(
      webhookId: any,
      webhookToken: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhookByToken(webhookId, webhookToken, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.deleteWebhookByToken"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {any} messageId
     * @param {any} [threadId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteWebhookMessage(
      webhookId: any,
      webhookToken: string,
      messageId: any,
      threadId?: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhookMessage(
        webhookId,
        webhookToken,
        messageId,
        threadId,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.deleteWebhookMessage"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {GithubWebhook} githubWebhook
     * @param {boolean} [wait]
     * @param {any} [threadId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async executeGithubCompatibleWebhook(
      webhookId: any,
      webhookToken: string,
      githubWebhook: GithubWebhook,
      wait?: boolean,
      threadId?: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.executeGithubCompatibleWebhook(
        webhookId,
        webhookToken,
        githubWebhook,
        wait,
        threadId,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.executeGithubCompatibleWebhook"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {SlackWebhook} slackWebhook
     * @param {boolean} [wait]
     * @param {any} [threadId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async executeSlackCompatibleWebhook(
      webhookId: any,
      webhookToken: string,
      slackWebhook: SlackWebhook,
      wait?: boolean,
      threadId?: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.executeSlackCompatibleWebhook(
        webhookId,
        webhookToken,
        slackWebhook,
        wait,
        threadId,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.executeSlackCompatibleWebhook"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {ExecuteWebhookRequest} executeWebhookRequest
     * @param {boolean} [wait]
     * @param {any} [threadId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async executeWebhook(
      webhookId: any,
      webhookToken: string,
      executeWebhookRequest: ExecuteWebhookRequest,
      wait?: boolean,
      threadId?: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.executeWebhook(
        webhookId,
        webhookToken,
        executeWebhookRequest,
        wait,
        threadId,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.executeWebhook"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {FollowChannelRequest} followChannelRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async followChannel(
      channelId: any,
      followChannelRequest: FollowChannelRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelFollowerResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.followChannel(channelId, followChannelRequest, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.followChannel"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getActiveGuildThreads(
      guildId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveGuildThreads(guildId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getActiveGuildThreads"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} applicationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApplication(
      applicationId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrivateApplicationResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApplication(applicationId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getApplication"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} commandId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApplicationCommand(
      applicationId: any,
      commandId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationCommandResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationCommand(
        applicationId,
        commandId,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getApplicationCommand"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} applicationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApplicationRoleConnectionsMetadata(
      applicationId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationRoleConnectionsMetadataItemResponse>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationRoleConnectionsMetadata(
        applicationId,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getApplicationRoleConnectionsMetadata"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} applicationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApplicationUserRoleConnection(
      applicationId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationUserRoleConnectionResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationUserRoleConnection(
        applicationId,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getApplicationUserRoleConnection"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {any} ruleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAutoModerationRule(
      guildId: any,
      ruleId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAutoModerationRule200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAutoModerationRule(guildId, ruleId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getAutoModerationRule"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBotGateway(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewayBotResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBotGateway(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getBotGateway"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getChannel(
      channelId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListGuildChannels200ResponseInner>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getChannel(channelId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getChannel"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGateway(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewayResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGateway(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getGateway"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {boolean} [withCounts]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGuild(
      guildId: any,
      withCounts?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildWithCountsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGuild(guildId, withCounts, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getGuild"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} guildId
     * @param {any} commandId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGuildApplicationCommand(
      applicationId: any,
      guildId: any,
      commandId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationCommandResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildApplicationCommand(
        applicationId,
        guildId,
        commandId,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getGuildApplicationCommand"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} guildId
     * @param {any} commandId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGuildApplicationCommandPermissions(
      applicationId: any,
      guildId: any,
      commandId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommandPermissionsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildApplicationCommandPermissions(
        applicationId,
        guildId,
        commandId,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getGuildApplicationCommandPermissions"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGuildBan(
      guildId: any,
      userId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildBanResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildBan(guildId, userId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getGuildBan"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {any} emojiId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGuildEmoji(
      guildId: any,
      emojiId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmojiResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildEmoji(guildId, emojiId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getGuildEmoji"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGuildMember(
      guildId: any,
      userId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildMemberResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildMember(guildId, userId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getGuildMember"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGuildNewMemberWelcome(
      guildId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildHomeSettingsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildNewMemberWelcome(guildId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getGuildNewMemberWelcome"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGuildPreview(
      guildId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildPreviewResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildPreview(guildId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getGuildPreview"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {any} guildScheduledEventId
     * @param {boolean} [withUserCount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGuildScheduledEvent(
      guildId: any,
      guildScheduledEventId: any,
      withUserCount?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGuildScheduledEvent200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildScheduledEvent(
        guildId,
        guildScheduledEventId,
        withUserCount,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getGuildScheduledEvent"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {any} stickerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGuildSticker(
      guildId: any,
      stickerId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildStickerResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildSticker(guildId, stickerId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getGuildSticker"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {string} code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGuildTemplate(
      code: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildTemplateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildTemplate(code, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getGuildTemplate"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGuildVanityUrl(
      guildId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VanityURLResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildVanityUrl(guildId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getGuildVanityUrl"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGuildWebhooks(
      guildId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListChannelWebhooks200ResponseInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildWebhooks(guildId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getGuildWebhooks"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGuildWelcomeScreen(
      guildId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildWelcomeScreenResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildWelcomeScreen(guildId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getGuildWelcomeScreen"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGuildWidget(
      guildId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WidgetResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildWidget(guildId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getGuildWidget"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {WidgetImageStyles} [style]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGuildWidgetPng(
      guildId: any,
      style?: WidgetImageStyles,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildWidgetPng(guildId, style, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getGuildWidgetPng"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGuildWidgetSettings(
      guildId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WidgetSettingsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildWidgetSettings(guildId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getGuildWidgetSettings"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGuildsOnboarding(
      guildId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGuildOnboardingResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGuildsOnboarding(guildId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getGuildsOnboarding"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMessage(
      channelId: any,
      messageId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMessage(channelId, messageId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getMessage"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMyApplication(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrivateApplicationResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMyApplication(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getMyApplication"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMyGuildMember(
      guildId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrivateGuildMemberResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMyGuildMember(guildId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getMyGuildMember"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMyOauth2Application(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrivateApplicationResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMyOauth2Application(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getMyOauth2Application"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMyOauth2Authorization(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuth2GetAuthorizationResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMyOauth2Authorization(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getMyOauth2Authorization"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMyUser(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPIIResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMyUser(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getMyUser"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {any} [threadId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOriginalWebhookMessage(
      webhookId: any,
      webhookToken: string,
      threadId?: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getOriginalWebhookMessage(
        webhookId,
        webhookToken,
        threadId,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getOriginalWebhookMessage"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStageInstance(
      channelId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StageInstanceResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStageInstance(channelId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getStageInstance"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} stickerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSticker(
      stickerId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSticker200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSticker(stickerId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getSticker"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {any} userId
     * @param {boolean} [withMember]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getThreadMember(
      channelId: any,
      userId: any,
      withMember?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadMemberResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getThreadMember(channelId, userId, withMember, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getThreadMember"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUser(
      userId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getUser"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWebhook(
      webhookId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListChannelWebhooks200ResponseInner>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhook(webhookId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getWebhook"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWebhookByToken(
      webhookId: any,
      webhookToken: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListChannelWebhooks200ResponseInner>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhookByToken(webhookId, webhookToken, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getWebhookByToken"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {any} messageId
     * @param {any} [threadId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWebhookMessage(
      webhookId: any,
      webhookToken: string,
      messageId: any,
      threadId?: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhookMessage(
        webhookId,
        webhookToken,
        messageId,
        threadId,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.getWebhookMessage"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {string} code
     * @param {boolean} [withCounts]
     * @param {any} [guildScheduledEventId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async inviteResolve(
      code: string,
      withCounts?: boolean,
      guildScheduledEventId?: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListChannelInvites200ResponseInner>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.inviteResolve(
        code,
        withCounts,
        guildScheduledEventId,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.inviteResolve"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {string} code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async inviteRevoke(
      code: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListChannelInvites200ResponseInner>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.inviteRevoke(code, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.inviteRevoke"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async joinThread(
      channelId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.joinThread(channelId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.joinThread"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async leaveGuild(
      guildId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.leaveGuild(guildId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.leaveGuild"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async leaveThread(
      channelId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.leaveThread(channelId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.leaveThread"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} applicationId
     * @param {boolean} [withLocalizations]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listApplicationCommands(
      applicationId: any,
      withLocalizations?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationCommandResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicationCommands(
        applicationId,
        withLocalizations,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listApplicationCommands"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAutoModerationRules(
      guildId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListAutoModerationRules200ResponseInner>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listAutoModerationRules(guildId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listAutoModerationRules"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listChannelInvites(
      channelId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListChannelInvites200ResponseInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listChannelInvites(channelId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listChannelInvites"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listChannelWebhooks(
      channelId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListChannelWebhooks200ResponseInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listChannelWebhooks(channelId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listChannelWebhooks"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listGuildApplicationCommandPermissions(
      applicationId: any,
      guildId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CommandPermissionsResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildApplicationCommandPermissions(
        applicationId,
        guildId,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listGuildApplicationCommandPermissions"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} guildId
     * @param {boolean} [withLocalizations]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listGuildApplicationCommands(
      applicationId: any,
      guildId: any,
      withLocalizations?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationCommandResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildApplicationCommands(
        applicationId,
        guildId,
        withLocalizations,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listGuildApplicationCommands"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {any} [userId]
     * @param {number} [actionType]
     * @param {any} [before]
     * @param {any} [after]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listGuildAuditLogEntries(
      guildId: any,
      userId?: any,
      actionType?: number,
      before?: any,
      after?: any,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildAuditLogResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildAuditLogEntries(
        guildId,
        userId,
        actionType,
        before,
        after,
        limit,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listGuildAuditLogEntries"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {number} [limit]
     * @param {any} [before]
     * @param {any} [after]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listGuildBans(
      guildId: any,
      limit?: number,
      before?: any,
      after?: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GuildBanResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildBans(guildId, limit, before, after, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listGuildBans"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listGuildChannels(
      guildId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListGuildChannels200ResponseInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildChannels(guildId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listGuildChannels"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listGuildEmojis(
      guildId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EmojiResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildEmojis(guildId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listGuildEmojis"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listGuildIntegrations(
      guildId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListGuildIntegrations200ResponseInner>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildIntegrations(guildId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listGuildIntegrations"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listGuildInvites(
      guildId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListChannelInvites200ResponseInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildInvites(guildId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listGuildInvites"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {number} [limit]
     * @param {number} [after]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listGuildMembers(
      guildId: any,
      limit?: number,
      after?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GuildMemberResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildMembers(guildId, limit, after, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listGuildMembers"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listGuildRoles(
      guildId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GuildRoleResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildRoles(guildId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listGuildRoles"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {any} guildScheduledEventId
     * @param {boolean} [withMember]
     * @param {number} [limit]
     * @param {any} [before]
     * @param {any} [after]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listGuildScheduledEventUsers(
      guildId: any,
      guildScheduledEventId: any,
      withMember?: boolean,
      limit?: number,
      before?: any,
      after?: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScheduledEventUserResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildScheduledEventUsers(
        guildId,
        guildScheduledEventId,
        withMember,
        limit,
        before,
        after,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listGuildScheduledEventUsers"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {boolean} [withUserCount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listGuildScheduledEvents(
      guildId: any,
      withUserCount?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetGuildScheduledEvent200Response>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildScheduledEvents(
        guildId,
        withUserCount,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listGuildScheduledEvents"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listGuildStickers(
      guildId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GuildStickerResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildStickers(guildId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listGuildStickers"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listGuildTemplates(
      guildId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GuildTemplateResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildTemplates(guildId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listGuildTemplates"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listGuildVoiceRegions(
      guildId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VoiceRegionResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listGuildVoiceRegions(guildId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listGuildVoiceRegions"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {string} emojiName
     * @param {any} [after]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listMessageReactionsByEmoji(
      channelId: any,
      messageId: any,
      emojiName: string,
      after?: any,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listMessageReactionsByEmoji(
        channelId,
        messageId,
        emojiName,
        after,
        limit,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listMessageReactionsByEmoji"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {any} [around]
     * @param {any} [before]
     * @param {any} [after]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listMessages(
      channelId: any,
      around?: any,
      before?: any,
      after?: any,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MessageResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listMessages(
        channelId,
        around,
        before,
        after,
        limit,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listMessages"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listMyConnections(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConnectedAccountResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listMyConnections(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listMyConnections"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} [before]
     * @param {any} [after]
     * @param {number} [limit]
     * @param {boolean} [withCounts]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listMyGuilds(
      before?: any,
      after?: any,
      limit?: number,
      withCounts?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MyGuildResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listMyGuilds(before, after, limit, withCounts, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listMyGuilds"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {any} [before]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listMyPrivateArchivedThreads(
      channelId: any,
      before?: any,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listMyPrivateArchivedThreads(
        channelId,
        before,
        limit,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listMyPrivateArchivedThreads"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listPinnedMessages(
      channelId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MessageResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listPinnedMessages(channelId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listPinnedMessages"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {string} [before]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listPrivateArchivedThreads(
      channelId: any,
      before?: string,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listPrivateArchivedThreads(
        channelId,
        before,
        limit,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listPrivateArchivedThreads"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {string} [before]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listPublicArchivedThreads(
      channelId: any,
      before?: string,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThreadsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listPublicArchivedThreads(
        channelId,
        before,
        limit,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listPublicArchivedThreads"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listStickerPacks(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StickerPackCollectionResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listStickerPacks(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listStickerPacks"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {boolean} [withMember]
     * @param {number} [limit]
     * @param {any} [after]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listThreadMembers(
      channelId: any,
      withMember?: boolean,
      limit?: number,
      after?: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ThreadMemberResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listThreadMembers(
        channelId,
        withMember,
        limit,
        after,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listThreadMembers"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listVoiceRegions(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VoiceRegionResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listVoiceRegions(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.listVoiceRegions"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pinMessage(
      channelId: any,
      messageId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pinMessage(channelId, messageId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.pinMessage"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {number} [days]
     * @param {string | null} [includeRoles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async previewPruneGuild(
      guildId: any,
      days?: number,
      includeRoles?: string | null,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildPruneResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.previewPruneGuild(guildId, days, includeRoles, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.previewPruneGuild"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {PruneGuildRequest} pruneGuildRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pruneGuild(
      guildId: any,
      pruneGuildRequest: PruneGuildRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildPruneResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pruneGuild(guildId, pruneGuildRequest, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.pruneGuild"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {UpdateGuildOnboardingRequest} updateGuildOnboardingRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putGuildsOnboarding(
      guildId: any,
      updateGuildOnboardingRequest: UpdateGuildOnboardingRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildOnboardingResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.putGuildsOnboarding(
        guildId,
        updateGuildOnboardingRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.putGuildsOnboarding"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {number} limit
     * @param {string} query
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchGuildMembers(
      limit: number,
      query: string,
      guildId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GuildMemberResponse>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchGuildMembers(limit, query, guildId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.searchGuildMembers"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {any} overwriteId
     * @param {SetChannelPermissionOverwriteRequest} setChannelPermissionOverwriteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setChannelPermissionOverwrite(
      channelId: any,
      overwriteId: any,
      setChannelPermissionOverwriteRequest: SetChannelPermissionOverwriteRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setChannelPermissionOverwrite(
        channelId,
        overwriteId,
        setChannelPermissionOverwriteRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.setChannelPermissionOverwrite"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} guildId
     * @param {any} commandId
     * @param {SetGuildApplicationCommandPermissionsRequest} setGuildApplicationCommandPermissionsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setGuildApplicationCommandPermissions(
      applicationId: any,
      guildId: any,
      commandId: any,
      setGuildApplicationCommandPermissionsRequest: SetGuildApplicationCommandPermissionsRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommandPermissionsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setGuildApplicationCommandPermissions(
        applicationId,
        guildId,
        commandId,
        setGuildApplicationCommandPermissionsRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.setGuildApplicationCommandPermissions"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {SetGuildMfaLevelRequest} setGuildMfaLevelRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setGuildMfaLevel(
      guildId: any,
      setGuildMfaLevelRequest: SetGuildMfaLevelRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildMFALevelResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setGuildMfaLevel(
        guildId,
        setGuildMfaLevelRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.setGuildMfaLevel"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {string} code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async syncGuildTemplate(
      guildId: any,
      code: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildTemplateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.syncGuildTemplate(guildId, code, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.syncGuildTemplate"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async triggerTypingIndicator(
      channelId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.triggerTypingIndicator(channelId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.triggerTypingIndicator"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unbanUserFromGuild(
      guildId: any,
      userId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unbanUserFromGuild(guildId, userId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.unbanUserFromGuild"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unpinMessage(
      channelId: any,
      messageId: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unpinMessage(channelId, messageId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.unpinMessage"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} applicationId
     * @param {ApplicationFormPartial} applicationFormPartial
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateApplication(
      applicationId: any,
      applicationFormPartial: ApplicationFormPartial,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrivateApplicationResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateApplication(
        applicationId,
        applicationFormPartial,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.updateApplication"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} commandId
     * @param {ApplicationCommandPatchRequestPartial} applicationCommandPatchRequestPartial
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateApplicationCommand(
      applicationId: any,
      commandId: any,
      applicationCommandPatchRequestPartial: ApplicationCommandPatchRequestPartial,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationCommandResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateApplicationCommand(
        applicationId,
        commandId,
        applicationCommandPatchRequestPartial,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.updateApplicationCommand"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} applicationId
     * @param {Array<ApplicationRoleConnectionsMetadataItemRequest>} applicationRoleConnectionsMetadataItemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateApplicationRoleConnectionsMetadata(
      applicationId: any,
      applicationRoleConnectionsMetadataItemRequest: Array<ApplicationRoleConnectionsMetadataItemRequest>,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicationRoleConnectionsMetadataItemResponse>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateApplicationRoleConnectionsMetadata(
        applicationId,
        applicationRoleConnectionsMetadataItemRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.updateApplicationRoleConnectionsMetadata"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} applicationId
     * @param {UpdateApplicationUserRoleConnectionRequest} updateApplicationUserRoleConnectionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateApplicationUserRoleConnection(
      applicationId: any,
      updateApplicationUserRoleConnectionRequest: UpdateApplicationUserRoleConnectionRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationUserRoleConnectionResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateApplicationUserRoleConnection(
        applicationId,
        updateApplicationUserRoleConnectionRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.updateApplicationUserRoleConnection"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {any} ruleId
     * @param {UpdateAutoModerationRuleRequest} updateAutoModerationRuleRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateAutoModerationRule(
      guildId: any,
      ruleId: any,
      updateAutoModerationRuleRequest: UpdateAutoModerationRuleRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAutoModerationRule200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateAutoModerationRule(
        guildId,
        ruleId,
        updateAutoModerationRuleRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.updateAutoModerationRule"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {UpdateChannelRequest} updateChannelRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateChannel(
      channelId: any,
      updateChannelRequest: UpdateChannelRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListGuildChannels200ResponseInner>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateChannel(channelId, updateChannelRequest, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.updateChannel"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {GuildPatchRequestPartial} guildPatchRequestPartial
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateGuild(
      guildId: any,
      guildPatchRequestPartial: GuildPatchRequestPartial,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateGuild(guildId, guildPatchRequestPartial, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.updateGuild"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} guildId
     * @param {any} commandId
     * @param {ApplicationCommandPatchRequestPartial} applicationCommandPatchRequestPartial
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateGuildApplicationCommand(
      applicationId: any,
      guildId: any,
      commandId: any,
      applicationCommandPatchRequestPartial: ApplicationCommandPatchRequestPartial,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationCommandResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateGuildApplicationCommand(
        applicationId,
        guildId,
        commandId,
        applicationCommandPatchRequestPartial,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.updateGuildApplicationCommand"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {any} emojiId
     * @param {UpdateGuildEmojiRequest} updateGuildEmojiRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateGuildEmoji(
      guildId: any,
      emojiId: any,
      updateGuildEmojiRequest: UpdateGuildEmojiRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmojiResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateGuildEmoji(
        guildId,
        emojiId,
        updateGuildEmojiRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.updateGuildEmoji"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {UpdateGuildMemberRequest} updateGuildMemberRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateGuildMember(
      guildId: any,
      userId: any,
      updateGuildMemberRequest: UpdateGuildMemberRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildMemberResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateGuildMember(
        guildId,
        userId,
        updateGuildMemberRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.updateGuildMember"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {any} roleId
     * @param {UpdateGuildRoleRequest} updateGuildRoleRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateGuildRole(
      guildId: any,
      roleId: any,
      updateGuildRoleRequest: UpdateGuildRoleRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildRoleResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateGuildRole(
        guildId,
        roleId,
        updateGuildRoleRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.updateGuildRole"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {any} guildScheduledEventId
     * @param {UpdateGuildScheduledEventRequest} updateGuildScheduledEventRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateGuildScheduledEvent(
      guildId: any,
      guildScheduledEventId: any,
      updateGuildScheduledEventRequest: UpdateGuildScheduledEventRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGuildScheduledEvent200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateGuildScheduledEvent(
        guildId,
        guildScheduledEventId,
        updateGuildScheduledEventRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.updateGuildScheduledEvent"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {any} stickerId
     * @param {UpdateGuildStickerRequest} updateGuildStickerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateGuildSticker(
      guildId: any,
      stickerId: any,
      updateGuildStickerRequest: UpdateGuildStickerRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildStickerResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateGuildSticker(
        guildId,
        stickerId,
        updateGuildStickerRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.updateGuildSticker"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {string} code
     * @param {UpdateGuildTemplateRequest} updateGuildTemplateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateGuildTemplate(
      guildId: any,
      code: string,
      updateGuildTemplateRequest: UpdateGuildTemplateRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildTemplateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateGuildTemplate(
        guildId,
        code,
        updateGuildTemplateRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.updateGuildTemplate"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {WelcomeScreenPatchRequestPartial} welcomeScreenPatchRequestPartial
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateGuildWelcomeScreen(
      guildId: any,
      welcomeScreenPatchRequestPartial: WelcomeScreenPatchRequestPartial,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildWelcomeScreenResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateGuildWelcomeScreen(
        guildId,
        welcomeScreenPatchRequestPartial,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.updateGuildWelcomeScreen"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {UpdateGuildWidgetSettingsRequest} updateGuildWidgetSettingsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateGuildWidgetSettings(
      guildId: any,
      updateGuildWidgetSettingsRequest: UpdateGuildWidgetSettingsRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WidgetSettingsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateGuildWidgetSettings(
        guildId,
        updateGuildWidgetSettingsRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.updateGuildWidgetSettings"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {MessageEditRequestPartial} messageEditRequestPartial
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateMessage(
      channelId: any,
      messageId: any,
      messageEditRequestPartial: MessageEditRequestPartial,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateMessage(
        channelId,
        messageId,
        messageEditRequestPartial,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.updateMessage"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {ApplicationFormPartial} applicationFormPartial
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateMyApplication(
      applicationFormPartial: ApplicationFormPartial,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrivateApplicationResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateMyApplication(applicationFormPartial, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.updateMyApplication"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {UpdateMyGuildMemberRequest} updateMyGuildMemberRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateMyGuildMember(
      guildId: any,
      updateMyGuildMemberRequest: UpdateMyGuildMemberRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrivateGuildMemberResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateMyGuildMember(
        guildId,
        updateMyGuildMemberRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.updateMyGuildMember"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {BotAccountPatchRequest} botAccountPatchRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateMyUser(
      botAccountPatchRequest: BotAccountPatchRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPIIResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateMyUser(botAccountPatchRequest, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.updateMyUser"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {IncomingWebhookUpdateRequestPartial} incomingWebhookUpdateRequestPartial
     * @param {any} [threadId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateOriginalWebhookMessage(
      webhookId: any,
      webhookToken: string,
      incomingWebhookUpdateRequestPartial: IncomingWebhookUpdateRequestPartial,
      threadId?: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateOriginalWebhookMessage(
        webhookId,
        webhookToken,
        incomingWebhookUpdateRequestPartial,
        threadId,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.updateOriginalWebhookMessage"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {UpdateSelfVoiceStateRequest} updateSelfVoiceStateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSelfVoiceState(
      guildId: any,
      updateSelfVoiceStateRequest: UpdateSelfVoiceStateRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateSelfVoiceState(
        guildId,
        updateSelfVoiceStateRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.updateSelfVoiceState"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} channelId
     * @param {UpdateStageInstanceRequest} updateStageInstanceRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateStageInstance(
      channelId: any,
      updateStageInstanceRequest: UpdateStageInstanceRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StageInstanceResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateStageInstance(
        channelId,
        updateStageInstanceRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.updateStageInstance"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {UpdateVoiceStateRequest} updateVoiceStateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateVoiceState(
      guildId: any,
      userId: any,
      updateVoiceStateRequest: UpdateVoiceStateRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateVoiceState(
        guildId,
        userId,
        updateVoiceStateRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.updateVoiceState"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} webhookId
     * @param {UpdateWebhookRequest} updateWebhookRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateWebhook(
      webhookId: any,
      updateWebhookRequest: UpdateWebhookRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListChannelWebhooks200ResponseInner>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(webhookId, updateWebhookRequest, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.updateWebhook"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {UpdateWebhookByTokenRequest} updateWebhookByTokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateWebhookByToken(
      webhookId: any,
      webhookToken: string,
      updateWebhookByTokenRequest: UpdateWebhookByTokenRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListChannelWebhooks200ResponseInner>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhookByToken(
        webhookId,
        webhookToken,
        updateWebhookByTokenRequest,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.updateWebhookByToken"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {any} messageId
     * @param {IncomingWebhookUpdateRequestPartial} incomingWebhookUpdateRequestPartial
     * @param {any} [threadId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateWebhookMessage(
      webhookId: any,
      webhookToken: string,
      messageId: any,
      incomingWebhookUpdateRequestPartial: IncomingWebhookUpdateRequestPartial,
      threadId?: any,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhookMessage(
        webhookId,
        webhookToken,
        messageId,
        incomingWebhookUpdateRequestPartial,
        threadId,
        options,
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap["DefaultApi.updateWebhookMessage"]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = DefaultApiFp(configuration);
  return {
    /**
     *
     * @param {any} channelId
     * @param {any} userId
     * @param {AddGroupDmUserRequest} addGroupDmUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGroupDmUser(
      channelId: any,
      userId: any,
      addGroupDmUserRequest: AddGroupDmUserRequest,
      options?: any,
    ): AxiosPromise<CreateDm200Response> {
      return localVarFp
        .addGroupDmUser(channelId, userId, addGroupDmUserRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {AddGuildMemberRequest} addGuildMemberRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGuildMember(
      guildId: any,
      userId: any,
      addGuildMemberRequest: AddGuildMemberRequest,
      options?: any,
    ): AxiosPromise<GuildMemberResponse> {
      return localVarFp
        .addGuildMember(guildId, userId, addGuildMemberRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {any} roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGuildMemberRole(guildId: any, userId: any, roleId: any, options?: any): AxiosPromise<void> {
      return localVarFp.addGuildMemberRole(guildId, userId, roleId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {string} emojiName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addMyMessageReaction(channelId: any, messageId: any, emojiName: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .addMyMessageReaction(channelId, messageId, emojiName, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {any} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addThreadMember(channelId: any, userId: any, options?: any): AxiosPromise<void> {
      return localVarFp.addThreadMember(channelId, userId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {BanUserFromGuildRequest} banUserFromGuildRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    banUserFromGuild(
      guildId: any,
      userId: any,
      banUserFromGuildRequest: BanUserFromGuildRequest,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .banUserFromGuild(guildId, userId, banUserFromGuildRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {BulkDeleteMessagesRequest} bulkDeleteMessagesRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkDeleteMessages(
      channelId: any,
      bulkDeleteMessagesRequest: BulkDeleteMessagesRequest,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .bulkDeleteMessages(channelId, bulkDeleteMessagesRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} applicationId
     * @param {Array<ApplicationCommandUpdateRequest>} applicationCommandUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkSetApplicationCommands(
      applicationId: any,
      applicationCommandUpdateRequest: Array<ApplicationCommandUpdateRequest>,
      options?: any,
    ): AxiosPromise<Array<ApplicationCommandResponse>> {
      return localVarFp
        .bulkSetApplicationCommands(applicationId, applicationCommandUpdateRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} guildId
     * @param {Array<ApplicationCommandUpdateRequest>} applicationCommandUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkSetGuildApplicationCommands(
      applicationId: any,
      guildId: any,
      applicationCommandUpdateRequest: Array<ApplicationCommandUpdateRequest>,
      options?: any,
    ): AxiosPromise<Array<ApplicationCommandResponse>> {
      return localVarFp
        .bulkSetGuildApplicationCommands(applicationId, guildId, applicationCommandUpdateRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {Array<BulkUpdateGuildChannelsRequestInner>} bulkUpdateGuildChannelsRequestInner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkUpdateGuildChannels(
      guildId: any,
      bulkUpdateGuildChannelsRequestInner: Array<BulkUpdateGuildChannelsRequestInner>,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .bulkUpdateGuildChannels(guildId, bulkUpdateGuildChannelsRequestInner, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {Array<BulkUpdateGuildRolesRequestInner>} bulkUpdateGuildRolesRequestInner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkUpdateGuildRoles(
      guildId: any,
      bulkUpdateGuildRolesRequestInner: Array<BulkUpdateGuildRolesRequestInner>,
      options?: any,
    ): AxiosPromise<Array<GuildRoleResponse>> {
      return localVarFp
        .bulkUpdateGuildRoles(guildId, bulkUpdateGuildRolesRequestInner, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} applicationId
     * @param {ApplicationCommandCreateRequest} applicationCommandCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApplicationCommand(
      applicationId: any,
      applicationCommandCreateRequest: ApplicationCommandCreateRequest,
      options?: any,
    ): AxiosPromise<ApplicationCommandResponse> {
      return localVarFp
        .createApplicationCommand(applicationId, applicationCommandCreateRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {CreateAutoModerationRuleRequest} createAutoModerationRuleRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAutoModerationRule(
      guildId: any,
      createAutoModerationRuleRequest: CreateAutoModerationRuleRequest,
      options?: any,
    ): AxiosPromise<GetAutoModerationRule200Response> {
      return localVarFp
        .createAutoModerationRule(guildId, createAutoModerationRuleRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {CreateChannelInviteRequest} createChannelInviteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createChannelInvite(
      channelId: any,
      createChannelInviteRequest: CreateChannelInviteRequest,
      options?: any,
    ): AxiosPromise<ListChannelInvites200ResponseInner> {
      return localVarFp
        .createChannelInvite(channelId, createChannelInviteRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {CreatePrivateChannelRequest} createPrivateChannelRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createDm(
      createPrivateChannelRequest: CreatePrivateChannelRequest,
      options?: any,
    ): AxiosPromise<CreateDm200Response> {
      return localVarFp.createDm(createPrivateChannelRequest, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {GuildCreateRequest} guildCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGuild(guildCreateRequest: GuildCreateRequest, options?: any): AxiosPromise<GuildResponse> {
      return localVarFp.createGuild(guildCreateRequest, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} guildId
     * @param {ApplicationCommandCreateRequest} applicationCommandCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGuildApplicationCommand(
      applicationId: any,
      guildId: any,
      applicationCommandCreateRequest: ApplicationCommandCreateRequest,
      options?: any,
    ): AxiosPromise<ApplicationCommandResponse> {
      return localVarFp
        .createGuildApplicationCommand(applicationId, guildId, applicationCommandCreateRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {CreateGuildChannelRequest} createGuildChannelRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGuildChannel(
      guildId: any,
      createGuildChannelRequest: CreateGuildChannelRequest,
      options?: any,
    ): AxiosPromise<GuildChannelResponse> {
      return localVarFp
        .createGuildChannel(guildId, createGuildChannelRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {CreateGuildEmojiRequest} createGuildEmojiRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGuildEmoji(
      guildId: any,
      createGuildEmojiRequest: CreateGuildEmojiRequest,
      options?: any,
    ): AxiosPromise<EmojiResponse> {
      return localVarFp
        .createGuildEmoji(guildId, createGuildEmojiRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} code
     * @param {CreateGuildFromTemplateRequest} createGuildFromTemplateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGuildFromTemplate(
      code: string,
      createGuildFromTemplateRequest: CreateGuildFromTemplateRequest,
      options?: any,
    ): AxiosPromise<GuildResponse> {
      return localVarFp
        .createGuildFromTemplate(code, createGuildFromTemplateRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {UpdateGuildRoleRequest} updateGuildRoleRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGuildRole(
      guildId: any,
      updateGuildRoleRequest: UpdateGuildRoleRequest,
      options?: any,
    ): AxiosPromise<GuildRoleResponse> {
      return localVarFp
        .createGuildRole(guildId, updateGuildRoleRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {CreateGuildScheduledEventRequest} createGuildScheduledEventRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGuildScheduledEvent(
      guildId: any,
      createGuildScheduledEventRequest: CreateGuildScheduledEventRequest,
      options?: any,
    ): AxiosPromise<GetGuildScheduledEvent200Response> {
      return localVarFp
        .createGuildScheduledEvent(guildId, createGuildScheduledEventRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {string} name
     * @param {string} tags
     * @param {string} file
     * @param {string | null} [description]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGuildSticker(
      guildId: any,
      name: string,
      tags: string,
      file: string,
      description?: string | null,
      options?: any,
    ): AxiosPromise<GuildStickerResponse> {
      return localVarFp
        .createGuildSticker(guildId, name, tags, file, description, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {CreateGuildTemplateRequest} createGuildTemplateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGuildTemplate(
      guildId: any,
      createGuildTemplateRequest: CreateGuildTemplateRequest,
      options?: any,
    ): AxiosPromise<GuildTemplateResponse> {
      return localVarFp
        .createGuildTemplate(guildId, createGuildTemplateRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} interactionId
     * @param {string} interactionToken
     * @param {CreateInteractionResponseRequest} createInteractionResponseRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInteractionResponse(
      interactionId: any,
      interactionToken: string,
      createInteractionResponseRequest: CreateInteractionResponseRequest,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .createInteractionResponse(interactionId, interactionToken, createInteractionResponseRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {MessageCreateRequest} messageCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMessage(
      channelId: any,
      messageCreateRequest: MessageCreateRequest,
      options?: any,
    ): AxiosPromise<MessageResponse> {
      return localVarFp
        .createMessage(channelId, messageCreateRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {CreateStageInstanceRequest} createStageInstanceRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createStageInstance(
      createStageInstanceRequest: CreateStageInstanceRequest,
      options?: any,
    ): AxiosPromise<StageInstanceResponse> {
      return localVarFp
        .createStageInstance(createStageInstanceRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {CreateThreadRequest} createThreadRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createThread(
      channelId: any,
      createThreadRequest: CreateThreadRequest,
      options?: any,
    ): AxiosPromise<CreatedThreadResponse> {
      return localVarFp.createThread(channelId, createThreadRequest, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {CreateTextThreadWithMessageRequest} createTextThreadWithMessageRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createThreadFromMessage(
      channelId: any,
      messageId: any,
      createTextThreadWithMessageRequest: CreateTextThreadWithMessageRequest,
      options?: any,
    ): AxiosPromise<ThreadResponse> {
      return localVarFp
        .createThreadFromMessage(channelId, messageId, createTextThreadWithMessageRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {CreateWebhookRequest} createWebhookRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWebhook(
      channelId: any,
      createWebhookRequest: CreateWebhookRequest,
      options?: any,
    ): AxiosPromise<GuildIncomingWebhookResponse> {
      return localVarFp
        .createWebhook(channelId, createWebhookRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    crosspostMessage(channelId: any, messageId: any, options?: any): AxiosPromise<MessageResponse> {
      return localVarFp.crosspostMessage(channelId, messageId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllMessageReactions(channelId: any, messageId: any, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteAllMessageReactions(channelId, messageId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {string} emojiName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllMessageReactionsByEmoji(
      channelId: any,
      messageId: any,
      emojiName: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteAllMessageReactionsByEmoji(channelId, messageId, emojiName, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} commandId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApplicationCommand(applicationId: any, commandId: any, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteApplicationCommand(applicationId, commandId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {any} ruleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAutoModerationRule(guildId: any, ruleId: any, options?: any): AxiosPromise<void> {
      return localVarFp.deleteAutoModerationRule(guildId, ruleId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteChannel(channelId: any, options?: any): AxiosPromise<ListGuildChannels200ResponseInner> {
      return localVarFp.deleteChannel(channelId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {any} overwriteId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteChannelPermissionOverwrite(channelId: any, overwriteId: any, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteChannelPermissionOverwrite(channelId, overwriteId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {any} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroupDmUser(channelId: any, userId: any, options?: any): AxiosPromise<void> {
      return localVarFp.deleteGroupDmUser(channelId, userId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGuild(guildId: any, options?: any): AxiosPromise<void> {
      return localVarFp.deleteGuild(guildId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} guildId
     * @param {any} commandId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGuildApplicationCommand(applicationId: any, guildId: any, commandId: any, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteGuildApplicationCommand(applicationId, guildId, commandId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {any} emojiId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGuildEmoji(guildId: any, emojiId: any, options?: any): AxiosPromise<void> {
      return localVarFp.deleteGuildEmoji(guildId, emojiId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {any} integrationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGuildIntegration(guildId: any, integrationId: any, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteGuildIntegration(guildId, integrationId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGuildMember(guildId: any, userId: any, options?: any): AxiosPromise<void> {
      return localVarFp.deleteGuildMember(guildId, userId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {any} roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGuildMemberRole(guildId: any, userId: any, roleId: any, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteGuildMemberRole(guildId, userId, roleId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {any} roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGuildRole(guildId: any, roleId: any, options?: any): AxiosPromise<void> {
      return localVarFp.deleteGuildRole(guildId, roleId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {any} guildScheduledEventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGuildScheduledEvent(guildId: any, guildScheduledEventId: any, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteGuildScheduledEvent(guildId, guildScheduledEventId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {any} stickerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGuildSticker(guildId: any, stickerId: any, options?: any): AxiosPromise<void> {
      return localVarFp.deleteGuildSticker(guildId, stickerId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {string} code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGuildTemplate(guildId: any, code: string, options?: any): AxiosPromise<GuildTemplateResponse> {
      return localVarFp.deleteGuildTemplate(guildId, code, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMessage(channelId: any, messageId: any, options?: any): AxiosPromise<void> {
      return localVarFp.deleteMessage(channelId, messageId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {string} emojiName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMyMessageReaction(channelId: any, messageId: any, emojiName: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteMyMessageReaction(channelId, messageId, emojiName, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {any} [threadId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOriginalWebhookMessage(
      webhookId: any,
      webhookToken: string,
      threadId?: any,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteOriginalWebhookMessage(webhookId, webhookToken, threadId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteStageInstance(channelId: any, options?: any): AxiosPromise<void> {
      return localVarFp.deleteStageInstance(channelId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {any} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteThreadMember(channelId: any, userId: any, options?: any): AxiosPromise<void> {
      return localVarFp.deleteThreadMember(channelId, userId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {string} emojiName
     * @param {any} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserMessageReaction(
      channelId: any,
      messageId: any,
      emojiName: string,
      userId: any,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteUserMessageReaction(channelId, messageId, emojiName, userId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhook(webhookId: any, options?: any): AxiosPromise<void> {
      return localVarFp.deleteWebhook(webhookId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhookByToken(webhookId: any, webhookToken: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteWebhookByToken(webhookId, webhookToken, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {any} messageId
     * @param {any} [threadId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhookMessage(
      webhookId: any,
      webhookToken: string,
      messageId: any,
      threadId?: any,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteWebhookMessage(webhookId, webhookToken, messageId, threadId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {GithubWebhook} githubWebhook
     * @param {boolean} [wait]
     * @param {any} [threadId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeGithubCompatibleWebhook(
      webhookId: any,
      webhookToken: string,
      githubWebhook: GithubWebhook,
      wait?: boolean,
      threadId?: any,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .executeGithubCompatibleWebhook(webhookId, webhookToken, githubWebhook, wait, threadId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {SlackWebhook} slackWebhook
     * @param {boolean} [wait]
     * @param {any} [threadId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeSlackCompatibleWebhook(
      webhookId: any,
      webhookToken: string,
      slackWebhook: SlackWebhook,
      wait?: boolean,
      threadId?: any,
      options?: any,
    ): AxiosPromise<string> {
      return localVarFp
        .executeSlackCompatibleWebhook(webhookId, webhookToken, slackWebhook, wait, threadId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {ExecuteWebhookRequest} executeWebhookRequest
     * @param {boolean} [wait]
     * @param {any} [threadId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeWebhook(
      webhookId: any,
      webhookToken: string,
      executeWebhookRequest: ExecuteWebhookRequest,
      wait?: boolean,
      threadId?: any,
      options?: any,
    ): AxiosPromise<MessageResponse> {
      return localVarFp
        .executeWebhook(webhookId, webhookToken, executeWebhookRequest, wait, threadId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {FollowChannelRequest} followChannelRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    followChannel(
      channelId: any,
      followChannelRequest: FollowChannelRequest,
      options?: any,
    ): AxiosPromise<ChannelFollowerResponse> {
      return localVarFp
        .followChannel(channelId, followChannelRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActiveGuildThreads(guildId: any, options?: any): AxiosPromise<ThreadsResponse> {
      return localVarFp.getActiveGuildThreads(guildId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} applicationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplication(applicationId: any, options?: any): AxiosPromise<PrivateApplicationResponse> {
      return localVarFp.getApplication(applicationId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} commandId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicationCommand(applicationId: any, commandId: any, options?: any): AxiosPromise<ApplicationCommandResponse> {
      return localVarFp
        .getApplicationCommand(applicationId, commandId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} applicationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicationRoleConnectionsMetadata(
      applicationId: any,
      options?: any,
    ): AxiosPromise<Array<ApplicationRoleConnectionsMetadataItemResponse>> {
      return localVarFp
        .getApplicationRoleConnectionsMetadata(applicationId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} applicationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApplicationUserRoleConnection(
      applicationId: any,
      options?: any,
    ): AxiosPromise<ApplicationUserRoleConnectionResponse> {
      return localVarFp
        .getApplicationUserRoleConnection(applicationId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {any} ruleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAutoModerationRule(guildId: any, ruleId: any, options?: any): AxiosPromise<GetAutoModerationRule200Response> {
      return localVarFp.getAutoModerationRule(guildId, ruleId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBotGateway(options?: any): AxiosPromise<GatewayBotResponse> {
      return localVarFp.getBotGateway(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChannel(channelId: any, options?: any): AxiosPromise<ListGuildChannels200ResponseInner> {
      return localVarFp.getChannel(channelId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGateway(options?: any): AxiosPromise<GatewayResponse> {
      return localVarFp.getGateway(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {boolean} [withCounts]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuild(guildId: any, withCounts?: boolean, options?: any): AxiosPromise<GuildWithCountsResponse> {
      return localVarFp.getGuild(guildId, withCounts, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} guildId
     * @param {any} commandId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildApplicationCommand(
      applicationId: any,
      guildId: any,
      commandId: any,
      options?: any,
    ): AxiosPromise<ApplicationCommandResponse> {
      return localVarFp
        .getGuildApplicationCommand(applicationId, guildId, commandId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} guildId
     * @param {any} commandId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildApplicationCommandPermissions(
      applicationId: any,
      guildId: any,
      commandId: any,
      options?: any,
    ): AxiosPromise<CommandPermissionsResponse> {
      return localVarFp
        .getGuildApplicationCommandPermissions(applicationId, guildId, commandId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildBan(guildId: any, userId: any, options?: any): AxiosPromise<GuildBanResponse> {
      return localVarFp.getGuildBan(guildId, userId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {any} emojiId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildEmoji(guildId: any, emojiId: any, options?: any): AxiosPromise<EmojiResponse> {
      return localVarFp.getGuildEmoji(guildId, emojiId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildMember(guildId: any, userId: any, options?: any): AxiosPromise<GuildMemberResponse> {
      return localVarFp.getGuildMember(guildId, userId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildNewMemberWelcome(guildId: any, options?: any): AxiosPromise<GuildHomeSettingsResponse> {
      return localVarFp.getGuildNewMemberWelcome(guildId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildPreview(guildId: any, options?: any): AxiosPromise<GuildPreviewResponse> {
      return localVarFp.getGuildPreview(guildId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {any} guildScheduledEventId
     * @param {boolean} [withUserCount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildScheduledEvent(
      guildId: any,
      guildScheduledEventId: any,
      withUserCount?: boolean,
      options?: any,
    ): AxiosPromise<GetGuildScheduledEvent200Response> {
      return localVarFp
        .getGuildScheduledEvent(guildId, guildScheduledEventId, withUserCount, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {any} stickerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildSticker(guildId: any, stickerId: any, options?: any): AxiosPromise<GuildStickerResponse> {
      return localVarFp.getGuildSticker(guildId, stickerId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildTemplate(code: string, options?: any): AxiosPromise<GuildTemplateResponse> {
      return localVarFp.getGuildTemplate(code, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildVanityUrl(guildId: any, options?: any): AxiosPromise<VanityURLResponse> {
      return localVarFp.getGuildVanityUrl(guildId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildWebhooks(guildId: any, options?: any): AxiosPromise<Array<ListChannelWebhooks200ResponseInner>> {
      return localVarFp.getGuildWebhooks(guildId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildWelcomeScreen(guildId: any, options?: any): AxiosPromise<GuildWelcomeScreenResponse> {
      return localVarFp.getGuildWelcomeScreen(guildId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildWidget(guildId: any, options?: any): AxiosPromise<WidgetResponse> {
      return localVarFp.getGuildWidget(guildId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {WidgetImageStyles} [style]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildWidgetPng(guildId: any, style?: WidgetImageStyles, options?: any): AxiosPromise<string> {
      return localVarFp.getGuildWidgetPng(guildId, style, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildWidgetSettings(guildId: any, options?: any): AxiosPromise<WidgetSettingsResponse> {
      return localVarFp.getGuildWidgetSettings(guildId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGuildsOnboarding(guildId: any, options?: any): AxiosPromise<UserGuildOnboardingResponse> {
      return localVarFp.getGuildsOnboarding(guildId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessage(channelId: any, messageId: any, options?: any): AxiosPromise<MessageResponse> {
      return localVarFp.getMessage(channelId, messageId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyApplication(options?: any): AxiosPromise<PrivateApplicationResponse> {
      return localVarFp.getMyApplication(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyGuildMember(guildId: any, options?: any): AxiosPromise<PrivateGuildMemberResponse> {
      return localVarFp.getMyGuildMember(guildId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyOauth2Application(options?: any): AxiosPromise<PrivateApplicationResponse> {
      return localVarFp.getMyOauth2Application(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyOauth2Authorization(options?: any): AxiosPromise<OAuth2GetAuthorizationResponse> {
      return localVarFp.getMyOauth2Authorization(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMyUser(options?: any): AxiosPromise<UserPIIResponse> {
      return localVarFp.getMyUser(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {any} [threadId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOriginalWebhookMessage(
      webhookId: any,
      webhookToken: string,
      threadId?: any,
      options?: any,
    ): AxiosPromise<MessageResponse> {
      return localVarFp
        .getOriginalWebhookMessage(webhookId, webhookToken, threadId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStageInstance(channelId: any, options?: any): AxiosPromise<StageInstanceResponse> {
      return localVarFp.getStageInstance(channelId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} stickerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSticker(stickerId: any, options?: any): AxiosPromise<GetSticker200Response> {
      return localVarFp.getSticker(stickerId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {any} userId
     * @param {boolean} [withMember]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getThreadMember(
      channelId: any,
      userId: any,
      withMember?: boolean,
      options?: any,
    ): AxiosPromise<ThreadMemberResponse> {
      return localVarFp
        .getThreadMember(channelId, userId, withMember, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(userId: any, options?: any): AxiosPromise<UserResponse> {
      return localVarFp.getUser(userId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhook(webhookId: any, options?: any): AxiosPromise<ListChannelWebhooks200ResponseInner> {
      return localVarFp.getWebhook(webhookId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhookByToken(
      webhookId: any,
      webhookToken: string,
      options?: any,
    ): AxiosPromise<ListChannelWebhooks200ResponseInner> {
      return localVarFp.getWebhookByToken(webhookId, webhookToken, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {any} messageId
     * @param {any} [threadId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhookMessage(
      webhookId: any,
      webhookToken: string,
      messageId: any,
      threadId?: any,
      options?: any,
    ): AxiosPromise<MessageResponse> {
      return localVarFp
        .getWebhookMessage(webhookId, webhookToken, messageId, threadId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} code
     * @param {boolean} [withCounts]
     * @param {any} [guildScheduledEventId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    inviteResolve(
      code: string,
      withCounts?: boolean,
      guildScheduledEventId?: any,
      options?: any,
    ): AxiosPromise<ListChannelInvites200ResponseInner> {
      return localVarFp
        .inviteResolve(code, withCounts, guildScheduledEventId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {string} code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    inviteRevoke(code: string, options?: any): AxiosPromise<ListChannelInvites200ResponseInner> {
      return localVarFp.inviteRevoke(code, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    joinThread(channelId: any, options?: any): AxiosPromise<void> {
      return localVarFp.joinThread(channelId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaveGuild(guildId: any, options?: any): AxiosPromise<void> {
      return localVarFp.leaveGuild(guildId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaveThread(channelId: any, options?: any): AxiosPromise<void> {
      return localVarFp.leaveThread(channelId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} applicationId
     * @param {boolean} [withLocalizations]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listApplicationCommands(
      applicationId: any,
      withLocalizations?: boolean,
      options?: any,
    ): AxiosPromise<Array<ApplicationCommandResponse>> {
      return localVarFp
        .listApplicationCommands(applicationId, withLocalizations, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAutoModerationRules(guildId: any, options?: any): AxiosPromise<Array<ListAutoModerationRules200ResponseInner>> {
      return localVarFp.listAutoModerationRules(guildId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listChannelInvites(channelId: any, options?: any): AxiosPromise<Array<ListChannelInvites200ResponseInner>> {
      return localVarFp.listChannelInvites(channelId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listChannelWebhooks(channelId: any, options?: any): AxiosPromise<Array<ListChannelWebhooks200ResponseInner>> {
      return localVarFp.listChannelWebhooks(channelId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildApplicationCommandPermissions(
      applicationId: any,
      guildId: any,
      options?: any,
    ): AxiosPromise<Array<CommandPermissionsResponse>> {
      return localVarFp
        .listGuildApplicationCommandPermissions(applicationId, guildId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} guildId
     * @param {boolean} [withLocalizations]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildApplicationCommands(
      applicationId: any,
      guildId: any,
      withLocalizations?: boolean,
      options?: any,
    ): AxiosPromise<Array<ApplicationCommandResponse>> {
      return localVarFp
        .listGuildApplicationCommands(applicationId, guildId, withLocalizations, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {any} [userId]
     * @param {number} [actionType]
     * @param {any} [before]
     * @param {any} [after]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildAuditLogEntries(
      guildId: any,
      userId?: any,
      actionType?: number,
      before?: any,
      after?: any,
      limit?: number,
      options?: any,
    ): AxiosPromise<GuildAuditLogResponse> {
      return localVarFp
        .listGuildAuditLogEntries(guildId, userId, actionType, before, after, limit, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {number} [limit]
     * @param {any} [before]
     * @param {any} [after]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildBans(
      guildId: any,
      limit?: number,
      before?: any,
      after?: any,
      options?: any,
    ): AxiosPromise<Array<GuildBanResponse>> {
      return localVarFp.listGuildBans(guildId, limit, before, after, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildChannels(guildId: any, options?: any): AxiosPromise<Array<ListGuildChannels200ResponseInner>> {
      return localVarFp.listGuildChannels(guildId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildEmojis(guildId: any, options?: any): AxiosPromise<Array<EmojiResponse>> {
      return localVarFp.listGuildEmojis(guildId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildIntegrations(guildId: any, options?: any): AxiosPromise<Array<ListGuildIntegrations200ResponseInner>> {
      return localVarFp.listGuildIntegrations(guildId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildInvites(guildId: any, options?: any): AxiosPromise<Array<ListChannelInvites200ResponseInner>> {
      return localVarFp.listGuildInvites(guildId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {number} [limit]
     * @param {number} [after]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildMembers(
      guildId: any,
      limit?: number,
      after?: number,
      options?: any,
    ): AxiosPromise<Array<GuildMemberResponse>> {
      return localVarFp.listGuildMembers(guildId, limit, after, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildRoles(guildId: any, options?: any): AxiosPromise<Array<GuildRoleResponse>> {
      return localVarFp.listGuildRoles(guildId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {any} guildScheduledEventId
     * @param {boolean} [withMember]
     * @param {number} [limit]
     * @param {any} [before]
     * @param {any} [after]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildScheduledEventUsers(
      guildId: any,
      guildScheduledEventId: any,
      withMember?: boolean,
      limit?: number,
      before?: any,
      after?: any,
      options?: any,
    ): AxiosPromise<Array<ScheduledEventUserResponse>> {
      return localVarFp
        .listGuildScheduledEventUsers(guildId, guildScheduledEventId, withMember, limit, before, after, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {boolean} [withUserCount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildScheduledEvents(
      guildId: any,
      withUserCount?: boolean,
      options?: any,
    ): AxiosPromise<Array<GetGuildScheduledEvent200Response>> {
      return localVarFp
        .listGuildScheduledEvents(guildId, withUserCount, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildStickers(guildId: any, options?: any): AxiosPromise<Array<GuildStickerResponse>> {
      return localVarFp.listGuildStickers(guildId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildTemplates(guildId: any, options?: any): AxiosPromise<Array<GuildTemplateResponse>> {
      return localVarFp.listGuildTemplates(guildId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGuildVoiceRegions(guildId: any, options?: any): AxiosPromise<Array<VoiceRegionResponse>> {
      return localVarFp.listGuildVoiceRegions(guildId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {string} emojiName
     * @param {any} [after]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMessageReactionsByEmoji(
      channelId: any,
      messageId: any,
      emojiName: string,
      after?: any,
      limit?: number,
      options?: any,
    ): AxiosPromise<Array<UserResponse>> {
      return localVarFp
        .listMessageReactionsByEmoji(channelId, messageId, emojiName, after, limit, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {any} [around]
     * @param {any} [before]
     * @param {any} [after]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMessages(
      channelId: any,
      around?: any,
      before?: any,
      after?: any,
      limit?: number,
      options?: any,
    ): AxiosPromise<Array<MessageResponse>> {
      return localVarFp
        .listMessages(channelId, around, before, after, limit, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMyConnections(options?: any): AxiosPromise<Array<ConnectedAccountResponse>> {
      return localVarFp.listMyConnections(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} [before]
     * @param {any} [after]
     * @param {number} [limit]
     * @param {boolean} [withCounts]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMyGuilds(
      before?: any,
      after?: any,
      limit?: number,
      withCounts?: boolean,
      options?: any,
    ): AxiosPromise<Array<MyGuildResponse>> {
      return localVarFp
        .listMyGuilds(before, after, limit, withCounts, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {any} [before]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listMyPrivateArchivedThreads(
      channelId: any,
      before?: any,
      limit?: number,
      options?: any,
    ): AxiosPromise<ThreadsResponse> {
      return localVarFp
        .listMyPrivateArchivedThreads(channelId, before, limit, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPinnedMessages(channelId: any, options?: any): AxiosPromise<Array<MessageResponse>> {
      return localVarFp.listPinnedMessages(channelId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {string} [before]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPrivateArchivedThreads(
      channelId: any,
      before?: string,
      limit?: number,
      options?: any,
    ): AxiosPromise<ThreadsResponse> {
      return localVarFp
        .listPrivateArchivedThreads(channelId, before, limit, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {string} [before]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPublicArchivedThreads(
      channelId: any,
      before?: string,
      limit?: number,
      options?: any,
    ): AxiosPromise<ThreadsResponse> {
      return localVarFp
        .listPublicArchivedThreads(channelId, before, limit, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listStickerPacks(options?: any): AxiosPromise<StickerPackCollectionResponse> {
      return localVarFp.listStickerPacks(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {boolean} [withMember]
     * @param {number} [limit]
     * @param {any} [after]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listThreadMembers(
      channelId: any,
      withMember?: boolean,
      limit?: number,
      after?: any,
      options?: any,
    ): AxiosPromise<Array<ThreadMemberResponse>> {
      return localVarFp
        .listThreadMembers(channelId, withMember, limit, after, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listVoiceRegions(options?: any): AxiosPromise<Array<VoiceRegionResponse>> {
      return localVarFp.listVoiceRegions(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pinMessage(channelId: any, messageId: any, options?: any): AxiosPromise<void> {
      return localVarFp.pinMessage(channelId, messageId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {number} [days]
     * @param {string | null} [includeRoles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    previewPruneGuild(
      guildId: any,
      days?: number,
      includeRoles?: string | null,
      options?: any,
    ): AxiosPromise<GuildPruneResponse> {
      return localVarFp
        .previewPruneGuild(guildId, days, includeRoles, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {PruneGuildRequest} pruneGuildRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pruneGuild(guildId: any, pruneGuildRequest: PruneGuildRequest, options?: any): AxiosPromise<GuildPruneResponse> {
      return localVarFp.pruneGuild(guildId, pruneGuildRequest, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {UpdateGuildOnboardingRequest} updateGuildOnboardingRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putGuildsOnboarding(
      guildId: any,
      updateGuildOnboardingRequest: UpdateGuildOnboardingRequest,
      options?: any,
    ): AxiosPromise<GuildOnboardingResponse> {
      return localVarFp
        .putGuildsOnboarding(guildId, updateGuildOnboardingRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {number} limit
     * @param {string} query
     * @param {any} guildId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchGuildMembers(
      limit: number,
      query: string,
      guildId: any,
      options?: any,
    ): AxiosPromise<Array<GuildMemberResponse>> {
      return localVarFp.searchGuildMembers(limit, query, guildId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {any} overwriteId
     * @param {SetChannelPermissionOverwriteRequest} setChannelPermissionOverwriteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setChannelPermissionOverwrite(
      channelId: any,
      overwriteId: any,
      setChannelPermissionOverwriteRequest: SetChannelPermissionOverwriteRequest,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .setChannelPermissionOverwrite(channelId, overwriteId, setChannelPermissionOverwriteRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} guildId
     * @param {any} commandId
     * @param {SetGuildApplicationCommandPermissionsRequest} setGuildApplicationCommandPermissionsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setGuildApplicationCommandPermissions(
      applicationId: any,
      guildId: any,
      commandId: any,
      setGuildApplicationCommandPermissionsRequest: SetGuildApplicationCommandPermissionsRequest,
      options?: any,
    ): AxiosPromise<CommandPermissionsResponse> {
      return localVarFp
        .setGuildApplicationCommandPermissions(
          applicationId,
          guildId,
          commandId,
          setGuildApplicationCommandPermissionsRequest,
          options,
        )
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {SetGuildMfaLevelRequest} setGuildMfaLevelRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setGuildMfaLevel(
      guildId: any,
      setGuildMfaLevelRequest: SetGuildMfaLevelRequest,
      options?: any,
    ): AxiosPromise<GuildMFALevelResponse> {
      return localVarFp
        .setGuildMfaLevel(guildId, setGuildMfaLevelRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {string} code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    syncGuildTemplate(guildId: any, code: string, options?: any): AxiosPromise<GuildTemplateResponse> {
      return localVarFp.syncGuildTemplate(guildId, code, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    triggerTypingIndicator(channelId: any, options?: any): AxiosPromise<any> {
      return localVarFp.triggerTypingIndicator(channelId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unbanUserFromGuild(guildId: any, userId: any, options?: any): AxiosPromise<void> {
      return localVarFp.unbanUserFromGuild(guildId, userId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unpinMessage(channelId: any, messageId: any, options?: any): AxiosPromise<void> {
      return localVarFp.unpinMessage(channelId, messageId, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} applicationId
     * @param {ApplicationFormPartial} applicationFormPartial
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateApplication(
      applicationId: any,
      applicationFormPartial: ApplicationFormPartial,
      options?: any,
    ): AxiosPromise<PrivateApplicationResponse> {
      return localVarFp
        .updateApplication(applicationId, applicationFormPartial, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} commandId
     * @param {ApplicationCommandPatchRequestPartial} applicationCommandPatchRequestPartial
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateApplicationCommand(
      applicationId: any,
      commandId: any,
      applicationCommandPatchRequestPartial: ApplicationCommandPatchRequestPartial,
      options?: any,
    ): AxiosPromise<ApplicationCommandResponse> {
      return localVarFp
        .updateApplicationCommand(applicationId, commandId, applicationCommandPatchRequestPartial, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} applicationId
     * @param {Array<ApplicationRoleConnectionsMetadataItemRequest>} applicationRoleConnectionsMetadataItemRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateApplicationRoleConnectionsMetadata(
      applicationId: any,
      applicationRoleConnectionsMetadataItemRequest: Array<ApplicationRoleConnectionsMetadataItemRequest>,
      options?: any,
    ): AxiosPromise<Array<ApplicationRoleConnectionsMetadataItemResponse>> {
      return localVarFp
        .updateApplicationRoleConnectionsMetadata(applicationId, applicationRoleConnectionsMetadataItemRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} applicationId
     * @param {UpdateApplicationUserRoleConnectionRequest} updateApplicationUserRoleConnectionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateApplicationUserRoleConnection(
      applicationId: any,
      updateApplicationUserRoleConnectionRequest: UpdateApplicationUserRoleConnectionRequest,
      options?: any,
    ): AxiosPromise<ApplicationUserRoleConnectionResponse> {
      return localVarFp
        .updateApplicationUserRoleConnection(applicationId, updateApplicationUserRoleConnectionRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {any} ruleId
     * @param {UpdateAutoModerationRuleRequest} updateAutoModerationRuleRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAutoModerationRule(
      guildId: any,
      ruleId: any,
      updateAutoModerationRuleRequest: UpdateAutoModerationRuleRequest,
      options?: any,
    ): AxiosPromise<GetAutoModerationRule200Response> {
      return localVarFp
        .updateAutoModerationRule(guildId, ruleId, updateAutoModerationRuleRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {UpdateChannelRequest} updateChannelRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateChannel(
      channelId: any,
      updateChannelRequest: UpdateChannelRequest,
      options?: any,
    ): AxiosPromise<ListGuildChannels200ResponseInner> {
      return localVarFp
        .updateChannel(channelId, updateChannelRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {GuildPatchRequestPartial} guildPatchRequestPartial
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGuild(
      guildId: any,
      guildPatchRequestPartial: GuildPatchRequestPartial,
      options?: any,
    ): AxiosPromise<GuildResponse> {
      return localVarFp
        .updateGuild(guildId, guildPatchRequestPartial, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} applicationId
     * @param {any} guildId
     * @param {any} commandId
     * @param {ApplicationCommandPatchRequestPartial} applicationCommandPatchRequestPartial
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGuildApplicationCommand(
      applicationId: any,
      guildId: any,
      commandId: any,
      applicationCommandPatchRequestPartial: ApplicationCommandPatchRequestPartial,
      options?: any,
    ): AxiosPromise<ApplicationCommandResponse> {
      return localVarFp
        .updateGuildApplicationCommand(
          applicationId,
          guildId,
          commandId,
          applicationCommandPatchRequestPartial,
          options,
        )
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {any} emojiId
     * @param {UpdateGuildEmojiRequest} updateGuildEmojiRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGuildEmoji(
      guildId: any,
      emojiId: any,
      updateGuildEmojiRequest: UpdateGuildEmojiRequest,
      options?: any,
    ): AxiosPromise<EmojiResponse> {
      return localVarFp
        .updateGuildEmoji(guildId, emojiId, updateGuildEmojiRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {UpdateGuildMemberRequest} updateGuildMemberRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGuildMember(
      guildId: any,
      userId: any,
      updateGuildMemberRequest: UpdateGuildMemberRequest,
      options?: any,
    ): AxiosPromise<GuildMemberResponse> {
      return localVarFp
        .updateGuildMember(guildId, userId, updateGuildMemberRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {any} roleId
     * @param {UpdateGuildRoleRequest} updateGuildRoleRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGuildRole(
      guildId: any,
      roleId: any,
      updateGuildRoleRequest: UpdateGuildRoleRequest,
      options?: any,
    ): AxiosPromise<GuildRoleResponse> {
      return localVarFp
        .updateGuildRole(guildId, roleId, updateGuildRoleRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {any} guildScheduledEventId
     * @param {UpdateGuildScheduledEventRequest} updateGuildScheduledEventRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGuildScheduledEvent(
      guildId: any,
      guildScheduledEventId: any,
      updateGuildScheduledEventRequest: UpdateGuildScheduledEventRequest,
      options?: any,
    ): AxiosPromise<GetGuildScheduledEvent200Response> {
      return localVarFp
        .updateGuildScheduledEvent(guildId, guildScheduledEventId, updateGuildScheduledEventRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {any} stickerId
     * @param {UpdateGuildStickerRequest} updateGuildStickerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGuildSticker(
      guildId: any,
      stickerId: any,
      updateGuildStickerRequest: UpdateGuildStickerRequest,
      options?: any,
    ): AxiosPromise<GuildStickerResponse> {
      return localVarFp
        .updateGuildSticker(guildId, stickerId, updateGuildStickerRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {string} code
     * @param {UpdateGuildTemplateRequest} updateGuildTemplateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGuildTemplate(
      guildId: any,
      code: string,
      updateGuildTemplateRequest: UpdateGuildTemplateRequest,
      options?: any,
    ): AxiosPromise<GuildTemplateResponse> {
      return localVarFp
        .updateGuildTemplate(guildId, code, updateGuildTemplateRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {WelcomeScreenPatchRequestPartial} welcomeScreenPatchRequestPartial
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGuildWelcomeScreen(
      guildId: any,
      welcomeScreenPatchRequestPartial: WelcomeScreenPatchRequestPartial,
      options?: any,
    ): AxiosPromise<GuildWelcomeScreenResponse> {
      return localVarFp
        .updateGuildWelcomeScreen(guildId, welcomeScreenPatchRequestPartial, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {UpdateGuildWidgetSettingsRequest} updateGuildWidgetSettingsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGuildWidgetSettings(
      guildId: any,
      updateGuildWidgetSettingsRequest: UpdateGuildWidgetSettingsRequest,
      options?: any,
    ): AxiosPromise<WidgetSettingsResponse> {
      return localVarFp
        .updateGuildWidgetSettings(guildId, updateGuildWidgetSettingsRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {any} messageId
     * @param {MessageEditRequestPartial} messageEditRequestPartial
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMessage(
      channelId: any,
      messageId: any,
      messageEditRequestPartial: MessageEditRequestPartial,
      options?: any,
    ): AxiosPromise<MessageResponse> {
      return localVarFp
        .updateMessage(channelId, messageId, messageEditRequestPartial, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {ApplicationFormPartial} applicationFormPartial
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMyApplication(
      applicationFormPartial: ApplicationFormPartial,
      options?: any,
    ): AxiosPromise<PrivateApplicationResponse> {
      return localVarFp.updateMyApplication(applicationFormPartial, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {UpdateMyGuildMemberRequest} updateMyGuildMemberRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMyGuildMember(
      guildId: any,
      updateMyGuildMemberRequest: UpdateMyGuildMemberRequest,
      options?: any,
    ): AxiosPromise<PrivateGuildMemberResponse> {
      return localVarFp
        .updateMyGuildMember(guildId, updateMyGuildMemberRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {BotAccountPatchRequest} botAccountPatchRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMyUser(botAccountPatchRequest: BotAccountPatchRequest, options?: any): AxiosPromise<UserPIIResponse> {
      return localVarFp.updateMyUser(botAccountPatchRequest, options).then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {IncomingWebhookUpdateRequestPartial} incomingWebhookUpdateRequestPartial
     * @param {any} [threadId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateOriginalWebhookMessage(
      webhookId: any,
      webhookToken: string,
      incomingWebhookUpdateRequestPartial: IncomingWebhookUpdateRequestPartial,
      threadId?: any,
      options?: any,
    ): AxiosPromise<MessageResponse> {
      return localVarFp
        .updateOriginalWebhookMessage(webhookId, webhookToken, incomingWebhookUpdateRequestPartial, threadId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {UpdateSelfVoiceStateRequest} updateSelfVoiceStateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSelfVoiceState(
      guildId: any,
      updateSelfVoiceStateRequest: UpdateSelfVoiceStateRequest,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .updateSelfVoiceState(guildId, updateSelfVoiceStateRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} channelId
     * @param {UpdateStageInstanceRequest} updateStageInstanceRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStageInstance(
      channelId: any,
      updateStageInstanceRequest: UpdateStageInstanceRequest,
      options?: any,
    ): AxiosPromise<StageInstanceResponse> {
      return localVarFp
        .updateStageInstance(channelId, updateStageInstanceRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} guildId
     * @param {any} userId
     * @param {UpdateVoiceStateRequest} updateVoiceStateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateVoiceState(
      guildId: any,
      userId: any,
      updateVoiceStateRequest: UpdateVoiceStateRequest,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .updateVoiceState(guildId, userId, updateVoiceStateRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} webhookId
     * @param {UpdateWebhookRequest} updateWebhookRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWebhook(
      webhookId: any,
      updateWebhookRequest: UpdateWebhookRequest,
      options?: any,
    ): AxiosPromise<ListChannelWebhooks200ResponseInner> {
      return localVarFp
        .updateWebhook(webhookId, updateWebhookRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {UpdateWebhookByTokenRequest} updateWebhookByTokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWebhookByToken(
      webhookId: any,
      webhookToken: string,
      updateWebhookByTokenRequest: UpdateWebhookByTokenRequest,
      options?: any,
    ): AxiosPromise<ListChannelWebhooks200ResponseInner> {
      return localVarFp
        .updateWebhookByToken(webhookId, webhookToken, updateWebhookByTokenRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @param {any} webhookId
     * @param {string} webhookToken
     * @param {any} messageId
     * @param {IncomingWebhookUpdateRequestPartial} incomingWebhookUpdateRequestPartial
     * @param {any} [threadId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWebhookMessage(
      webhookId: any,
      webhookToken: string,
      messageId: any,
      incomingWebhookUpdateRequestPartial: IncomingWebhookUpdateRequestPartial,
      threadId?: any,
      options?: any,
    ): AxiosPromise<MessageResponse> {
      return localVarFp
        .updateWebhookMessage(
          webhookId,
          webhookToken,
          messageId,
          incomingWebhookUpdateRequestPartial,
          threadId,
          options,
        )
        .then(request => request(axios, basePath));
    },
  };
};

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
  /**
   *
   * @param {any} channelId
   * @param {any} userId
   * @param {AddGroupDmUserRequest} addGroupDmUserRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  addGroupDmUser(
    channelId: any,
    userId: any,
    addGroupDmUserRequest: AddGroupDmUserRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<CreateDm200Response>;

  /**
   *
   * @param {any} guildId
   * @param {any} userId
   * @param {AddGuildMemberRequest} addGuildMemberRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  addGuildMember(
    guildId: any,
    userId: any,
    addGuildMemberRequest: AddGuildMemberRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GuildMemberResponse>;

  /**
   *
   * @param {any} guildId
   * @param {any} userId
   * @param {any} roleId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  addGuildMemberRole(guildId: any, userId: any, roleId: any, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @param {any} channelId
   * @param {any} messageId
   * @param {string} emojiName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  addMyMessageReaction(
    channelId: any,
    messageId: any,
    emojiName: string,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<void>;

  /**
   *
   * @param {any} channelId
   * @param {any} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  addThreadMember(channelId: any, userId: any, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @param {any} guildId
   * @param {any} userId
   * @param {BanUserFromGuildRequest} banUserFromGuildRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  banUserFromGuild(
    guildId: any,
    userId: any,
    banUserFromGuildRequest: BanUserFromGuildRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<void>;

  /**
   *
   * @param {any} channelId
   * @param {BulkDeleteMessagesRequest} bulkDeleteMessagesRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  bulkDeleteMessages(
    channelId: any,
    bulkDeleteMessagesRequest: BulkDeleteMessagesRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<void>;

  /**
   *
   * @param {any} applicationId
   * @param {Array<ApplicationCommandUpdateRequest>} applicationCommandUpdateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  bulkSetApplicationCommands(
    applicationId: any,
    applicationCommandUpdateRequest: Array<ApplicationCommandUpdateRequest>,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<Array<ApplicationCommandResponse>>;

  /**
   *
   * @param {any} applicationId
   * @param {any} guildId
   * @param {Array<ApplicationCommandUpdateRequest>} applicationCommandUpdateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  bulkSetGuildApplicationCommands(
    applicationId: any,
    guildId: any,
    applicationCommandUpdateRequest: Array<ApplicationCommandUpdateRequest>,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<Array<ApplicationCommandResponse>>;

  /**
   *
   * @param {any} guildId
   * @param {Array<BulkUpdateGuildChannelsRequestInner>} bulkUpdateGuildChannelsRequestInner
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  bulkUpdateGuildChannels(
    guildId: any,
    bulkUpdateGuildChannelsRequestInner: Array<BulkUpdateGuildChannelsRequestInner>,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<void>;

  /**
   *
   * @param {any} guildId
   * @param {Array<BulkUpdateGuildRolesRequestInner>} bulkUpdateGuildRolesRequestInner
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  bulkUpdateGuildRoles(
    guildId: any,
    bulkUpdateGuildRolesRequestInner: Array<BulkUpdateGuildRolesRequestInner>,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<Array<GuildRoleResponse>>;

  /**
   *
   * @param {any} applicationId
   * @param {ApplicationCommandCreateRequest} applicationCommandCreateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createApplicationCommand(
    applicationId: any,
    applicationCommandCreateRequest: ApplicationCommandCreateRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ApplicationCommandResponse>;

  /**
   *
   * @param {any} guildId
   * @param {CreateAutoModerationRuleRequest} createAutoModerationRuleRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createAutoModerationRule(
    guildId: any,
    createAutoModerationRuleRequest: CreateAutoModerationRuleRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GetAutoModerationRule200Response>;

  /**
   *
   * @param {any} channelId
   * @param {CreateChannelInviteRequest} createChannelInviteRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createChannelInvite(
    channelId: any,
    createChannelInviteRequest: CreateChannelInviteRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ListChannelInvites200ResponseInner>;

  /**
   *
   * @param {CreatePrivateChannelRequest} createPrivateChannelRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createDm(
    createPrivateChannelRequest: CreatePrivateChannelRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<CreateDm200Response>;

  /**
   *
   * @param {GuildCreateRequest} guildCreateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createGuild(guildCreateRequest: GuildCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<GuildResponse>;

  /**
   *
   * @param {any} applicationId
   * @param {any} guildId
   * @param {ApplicationCommandCreateRequest} applicationCommandCreateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createGuildApplicationCommand(
    applicationId: any,
    guildId: any,
    applicationCommandCreateRequest: ApplicationCommandCreateRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ApplicationCommandResponse>;

  /**
   *
   * @param {any} guildId
   * @param {CreateGuildChannelRequest} createGuildChannelRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createGuildChannel(
    guildId: any,
    createGuildChannelRequest: CreateGuildChannelRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GuildChannelResponse>;

  /**
   *
   * @param {any} guildId
   * @param {CreateGuildEmojiRequest} createGuildEmojiRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createGuildEmoji(
    guildId: any,
    createGuildEmojiRequest: CreateGuildEmojiRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<EmojiResponse>;

  /**
   *
   * @param {string} code
   * @param {CreateGuildFromTemplateRequest} createGuildFromTemplateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createGuildFromTemplate(
    code: string,
    createGuildFromTemplateRequest: CreateGuildFromTemplateRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GuildResponse>;

  /**
   *
   * @param {any} guildId
   * @param {UpdateGuildRoleRequest} updateGuildRoleRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createGuildRole(
    guildId: any,
    updateGuildRoleRequest: UpdateGuildRoleRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GuildRoleResponse>;

  /**
   *
   * @param {any} guildId
   * @param {CreateGuildScheduledEventRequest} createGuildScheduledEventRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createGuildScheduledEvent(
    guildId: any,
    createGuildScheduledEventRequest: CreateGuildScheduledEventRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GetGuildScheduledEvent200Response>;

  /**
   *
   * @param {any} guildId
   * @param {string} name
   * @param {string} tags
   * @param {string} file
   * @param {string | null} [description]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createGuildSticker(
    guildId: any,
    name: string,
    tags: string,
    file: string,
    description?: string | null,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GuildStickerResponse>;

  /**
   *
   * @param {any} guildId
   * @param {CreateGuildTemplateRequest} createGuildTemplateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createGuildTemplate(
    guildId: any,
    createGuildTemplateRequest: CreateGuildTemplateRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GuildTemplateResponse>;

  /**
   *
   * @param {any} interactionId
   * @param {string} interactionToken
   * @param {CreateInteractionResponseRequest} createInteractionResponseRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createInteractionResponse(
    interactionId: any,
    interactionToken: string,
    createInteractionResponseRequest: CreateInteractionResponseRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<void>;

  /**
   *
   * @param {any} channelId
   * @param {MessageCreateRequest} messageCreateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createMessage(
    channelId: any,
    messageCreateRequest: MessageCreateRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<MessageResponse>;

  /**
   *
   * @param {CreateStageInstanceRequest} createStageInstanceRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createStageInstance(
    createStageInstanceRequest: CreateStageInstanceRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<StageInstanceResponse>;

  /**
   *
   * @param {any} channelId
   * @param {CreateThreadRequest} createThreadRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createThread(
    channelId: any,
    createThreadRequest: CreateThreadRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<CreatedThreadResponse>;

  /**
   *
   * @param {any} channelId
   * @param {any} messageId
   * @param {CreateTextThreadWithMessageRequest} createTextThreadWithMessageRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createThreadFromMessage(
    channelId: any,
    messageId: any,
    createTextThreadWithMessageRequest: CreateTextThreadWithMessageRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ThreadResponse>;

  /**
   *
   * @param {any} channelId
   * @param {CreateWebhookRequest} createWebhookRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  createWebhook(
    channelId: any,
    createWebhookRequest: CreateWebhookRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GuildIncomingWebhookResponse>;

  /**
   *
   * @param {any} channelId
   * @param {any} messageId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  crosspostMessage(channelId: any, messageId: any, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponse>;

  /**
   *
   * @param {any} channelId
   * @param {any} messageId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  deleteAllMessageReactions(channelId: any, messageId: any, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @param {any} channelId
   * @param {any} messageId
   * @param {string} emojiName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  deleteAllMessageReactionsByEmoji(
    channelId: any,
    messageId: any,
    emojiName: string,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<void>;

  /**
   *
   * @param {any} applicationId
   * @param {any} commandId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  deleteApplicationCommand(applicationId: any, commandId: any, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @param {any} guildId
   * @param {any} ruleId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  deleteAutoModerationRule(guildId: any, ruleId: any, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @param {any} channelId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  deleteChannel(channelId: any, options?: RawAxiosRequestConfig): AxiosPromise<ListGuildChannels200ResponseInner>;

  /**
   *
   * @param {any} channelId
   * @param {any} overwriteId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  deleteChannelPermissionOverwrite(
    channelId: any,
    overwriteId: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<void>;

  /**
   *
   * @param {any} channelId
   * @param {any} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  deleteGroupDmUser(channelId: any, userId: any, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  deleteGuild(guildId: any, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @param {any} applicationId
   * @param {any} guildId
   * @param {any} commandId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  deleteGuildApplicationCommand(
    applicationId: any,
    guildId: any,
    commandId: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<void>;

  /**
   *
   * @param {any} guildId
   * @param {any} emojiId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  deleteGuildEmoji(guildId: any, emojiId: any, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @param {any} guildId
   * @param {any} integrationId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  deleteGuildIntegration(guildId: any, integrationId: any, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @param {any} guildId
   * @param {any} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  deleteGuildMember(guildId: any, userId: any, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @param {any} guildId
   * @param {any} userId
   * @param {any} roleId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  deleteGuildMemberRole(guildId: any, userId: any, roleId: any, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @param {any} guildId
   * @param {any} roleId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  deleteGuildRole(guildId: any, roleId: any, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @param {any} guildId
   * @param {any} guildScheduledEventId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  deleteGuildScheduledEvent(
    guildId: any,
    guildScheduledEventId: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<void>;

  /**
   *
   * @param {any} guildId
   * @param {any} stickerId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  deleteGuildSticker(guildId: any, stickerId: any, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @param {any} guildId
   * @param {string} code
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  deleteGuildTemplate(guildId: any, code: string, options?: RawAxiosRequestConfig): AxiosPromise<GuildTemplateResponse>;

  /**
   *
   * @param {any} channelId
   * @param {any} messageId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  deleteMessage(channelId: any, messageId: any, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @param {any} channelId
   * @param {any} messageId
   * @param {string} emojiName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  deleteMyMessageReaction(
    channelId: any,
    messageId: any,
    emojiName: string,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<void>;

  /**
   *
   * @param {any} webhookId
   * @param {string} webhookToken
   * @param {any} [threadId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  deleteOriginalWebhookMessage(
    webhookId: any,
    webhookToken: string,
    threadId?: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<void>;

  /**
   *
   * @param {any} channelId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  deleteStageInstance(channelId: any, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @param {any} channelId
   * @param {any} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  deleteThreadMember(channelId: any, userId: any, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @param {any} channelId
   * @param {any} messageId
   * @param {string} emojiName
   * @param {any} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  deleteUserMessageReaction(
    channelId: any,
    messageId: any,
    emojiName: string,
    userId: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<void>;

  /**
   *
   * @param {any} webhookId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  deleteWebhook(webhookId: any, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @param {any} webhookId
   * @param {string} webhookToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  deleteWebhookByToken(webhookId: any, webhookToken: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @param {any} webhookId
   * @param {string} webhookToken
   * @param {any} messageId
   * @param {any} [threadId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  deleteWebhookMessage(
    webhookId: any,
    webhookToken: string,
    messageId: any,
    threadId?: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<void>;

  /**
   *
   * @param {any} webhookId
   * @param {string} webhookToken
   * @param {GithubWebhook} githubWebhook
   * @param {boolean} [wait]
   * @param {any} [threadId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  executeGithubCompatibleWebhook(
    webhookId: any,
    webhookToken: string,
    githubWebhook: GithubWebhook,
    wait?: boolean,
    threadId?: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<void>;

  /**
   *
   * @param {any} webhookId
   * @param {string} webhookToken
   * @param {SlackWebhook} slackWebhook
   * @param {boolean} [wait]
   * @param {any} [threadId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  executeSlackCompatibleWebhook(
    webhookId: any,
    webhookToken: string,
    slackWebhook: SlackWebhook,
    wait?: boolean,
    threadId?: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<string>;

  /**
   *
   * @param {any} webhookId
   * @param {string} webhookToken
   * @param {ExecuteWebhookRequest} executeWebhookRequest
   * @param {boolean} [wait]
   * @param {any} [threadId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  executeWebhook(
    webhookId: any,
    webhookToken: string,
    executeWebhookRequest: ExecuteWebhookRequest,
    wait?: boolean,
    threadId?: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<MessageResponse>;

  /**
   *
   * @param {any} channelId
   * @param {FollowChannelRequest} followChannelRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  followChannel(
    channelId: any,
    followChannelRequest: FollowChannelRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ChannelFollowerResponse>;

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getActiveGuildThreads(guildId: any, options?: RawAxiosRequestConfig): AxiosPromise<ThreadsResponse>;

  /**
   *
   * @param {any} applicationId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getApplication(applicationId: any, options?: RawAxiosRequestConfig): AxiosPromise<PrivateApplicationResponse>;

  /**
   *
   * @param {any} applicationId
   * @param {any} commandId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getApplicationCommand(
    applicationId: any,
    commandId: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ApplicationCommandResponse>;

  /**
   *
   * @param {any} applicationId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getApplicationRoleConnectionsMetadata(
    applicationId: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<Array<ApplicationRoleConnectionsMetadataItemResponse>>;

  /**
   *
   * @param {any} applicationId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getApplicationUserRoleConnection(
    applicationId: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ApplicationUserRoleConnectionResponse>;

  /**
   *
   * @param {any} guildId
   * @param {any} ruleId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getAutoModerationRule(
    guildId: any,
    ruleId: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GetAutoModerationRule200Response>;

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getBotGateway(options?: RawAxiosRequestConfig): AxiosPromise<GatewayBotResponse>;

  /**
   *
   * @param {any} channelId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getChannel(channelId: any, options?: RawAxiosRequestConfig): AxiosPromise<ListGuildChannels200ResponseInner>;

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getGateway(options?: RawAxiosRequestConfig): AxiosPromise<GatewayResponse>;

  /**
   *
   * @param {any} guildId
   * @param {boolean} [withCounts]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getGuild(guildId: any, withCounts?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<GuildWithCountsResponse>;

  /**
   *
   * @param {any} applicationId
   * @param {any} guildId
   * @param {any} commandId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getGuildApplicationCommand(
    applicationId: any,
    guildId: any,
    commandId: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ApplicationCommandResponse>;

  /**
   *
   * @param {any} applicationId
   * @param {any} guildId
   * @param {any} commandId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getGuildApplicationCommandPermissions(
    applicationId: any,
    guildId: any,
    commandId: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<CommandPermissionsResponse>;

  /**
   *
   * @param {any} guildId
   * @param {any} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getGuildBan(guildId: any, userId: any, options?: RawAxiosRequestConfig): AxiosPromise<GuildBanResponse>;

  /**
   *
   * @param {any} guildId
   * @param {any} emojiId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getGuildEmoji(guildId: any, emojiId: any, options?: RawAxiosRequestConfig): AxiosPromise<EmojiResponse>;

  /**
   *
   * @param {any} guildId
   * @param {any} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getGuildMember(guildId: any, userId: any, options?: RawAxiosRequestConfig): AxiosPromise<GuildMemberResponse>;

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getGuildNewMemberWelcome(guildId: any, options?: RawAxiosRequestConfig): AxiosPromise<GuildHomeSettingsResponse>;

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getGuildPreview(guildId: any, options?: RawAxiosRequestConfig): AxiosPromise<GuildPreviewResponse>;

  /**
   *
   * @param {any} guildId
   * @param {any} guildScheduledEventId
   * @param {boolean} [withUserCount]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getGuildScheduledEvent(
    guildId: any,
    guildScheduledEventId: any,
    withUserCount?: boolean,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GetGuildScheduledEvent200Response>;

  /**
   *
   * @param {any} guildId
   * @param {any} stickerId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getGuildSticker(guildId: any, stickerId: any, options?: RawAxiosRequestConfig): AxiosPromise<GuildStickerResponse>;

  /**
   *
   * @param {string} code
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getGuildTemplate(code: string, options?: RawAxiosRequestConfig): AxiosPromise<GuildTemplateResponse>;

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getGuildVanityUrl(guildId: any, options?: RawAxiosRequestConfig): AxiosPromise<VanityURLResponse>;

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getGuildWebhooks(
    guildId: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<Array<ListChannelWebhooks200ResponseInner>>;

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getGuildWelcomeScreen(guildId: any, options?: RawAxiosRequestConfig): AxiosPromise<GuildWelcomeScreenResponse>;

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getGuildWidget(guildId: any, options?: RawAxiosRequestConfig): AxiosPromise<WidgetResponse>;

  /**
   *
   * @param {any} guildId
   * @param {WidgetImageStyles} [style]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getGuildWidgetPng(guildId: any, style?: WidgetImageStyles, options?: RawAxiosRequestConfig): AxiosPromise<string>;

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getGuildWidgetSettings(guildId: any, options?: RawAxiosRequestConfig): AxiosPromise<WidgetSettingsResponse>;

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getGuildsOnboarding(guildId: any, options?: RawAxiosRequestConfig): AxiosPromise<UserGuildOnboardingResponse>;

  /**
   *
   * @param {any} channelId
   * @param {any} messageId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getMessage(channelId: any, messageId: any, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponse>;

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getMyApplication(options?: RawAxiosRequestConfig): AxiosPromise<PrivateApplicationResponse>;

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getMyGuildMember(guildId: any, options?: RawAxiosRequestConfig): AxiosPromise<PrivateGuildMemberResponse>;

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getMyOauth2Application(options?: RawAxiosRequestConfig): AxiosPromise<PrivateApplicationResponse>;

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getMyOauth2Authorization(options?: RawAxiosRequestConfig): AxiosPromise<OAuth2GetAuthorizationResponse>;

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getMyUser(options?: RawAxiosRequestConfig): AxiosPromise<UserPIIResponse>;

  /**
   *
   * @param {any} webhookId
   * @param {string} webhookToken
   * @param {any} [threadId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getOriginalWebhookMessage(
    webhookId: any,
    webhookToken: string,
    threadId?: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<MessageResponse>;

  /**
   *
   * @param {any} channelId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getStageInstance(channelId: any, options?: RawAxiosRequestConfig): AxiosPromise<StageInstanceResponse>;

  /**
   *
   * @param {any} stickerId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getSticker(stickerId: any, options?: RawAxiosRequestConfig): AxiosPromise<GetSticker200Response>;

  /**
   *
   * @param {any} channelId
   * @param {any} userId
   * @param {boolean} [withMember]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getThreadMember(
    channelId: any,
    userId: any,
    withMember?: boolean,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ThreadMemberResponse>;

  /**
   *
   * @param {any} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getUser(userId: any, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse>;

  /**
   *
   * @param {any} webhookId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getWebhook(webhookId: any, options?: RawAxiosRequestConfig): AxiosPromise<ListChannelWebhooks200ResponseInner>;

  /**
   *
   * @param {any} webhookId
   * @param {string} webhookToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getWebhookByToken(
    webhookId: any,
    webhookToken: string,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ListChannelWebhooks200ResponseInner>;

  /**
   *
   * @param {any} webhookId
   * @param {string} webhookToken
   * @param {any} messageId
   * @param {any} [threadId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  getWebhookMessage(
    webhookId: any,
    webhookToken: string,
    messageId: any,
    threadId?: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<MessageResponse>;

  /**
   *
   * @param {string} code
   * @param {boolean} [withCounts]
   * @param {any} [guildScheduledEventId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  inviteResolve(
    code: string,
    withCounts?: boolean,
    guildScheduledEventId?: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ListChannelInvites200ResponseInner>;

  /**
   *
   * @param {string} code
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  inviteRevoke(code: string, options?: RawAxiosRequestConfig): AxiosPromise<ListChannelInvites200ResponseInner>;

  /**
   *
   * @param {any} channelId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  joinThread(channelId: any, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  leaveGuild(guildId: any, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @param {any} channelId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  leaveThread(channelId: any, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @param {any} applicationId
   * @param {boolean} [withLocalizations]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listApplicationCommands(
    applicationId: any,
    withLocalizations?: boolean,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<Array<ApplicationCommandResponse>>;

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listAutoModerationRules(
    guildId: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<Array<ListAutoModerationRules200ResponseInner>>;

  /**
   *
   * @param {any} channelId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listChannelInvites(
    channelId: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<Array<ListChannelInvites200ResponseInner>>;

  /**
   *
   * @param {any} channelId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listChannelWebhooks(
    channelId: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<Array<ListChannelWebhooks200ResponseInner>>;

  /**
   *
   * @param {any} applicationId
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listGuildApplicationCommandPermissions(
    applicationId: any,
    guildId: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<Array<CommandPermissionsResponse>>;

  /**
   *
   * @param {any} applicationId
   * @param {any} guildId
   * @param {boolean} [withLocalizations]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listGuildApplicationCommands(
    applicationId: any,
    guildId: any,
    withLocalizations?: boolean,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<Array<ApplicationCommandResponse>>;

  /**
   *
   * @param {any} guildId
   * @param {any} [userId]
   * @param {number} [actionType]
   * @param {any} [before]
   * @param {any} [after]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listGuildAuditLogEntries(
    guildId: any,
    userId?: any,
    actionType?: number,
    before?: any,
    after?: any,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GuildAuditLogResponse>;

  /**
   *
   * @param {any} guildId
   * @param {number} [limit]
   * @param {any} [before]
   * @param {any} [after]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listGuildBans(
    guildId: any,
    limit?: number,
    before?: any,
    after?: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<Array<GuildBanResponse>>;

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listGuildChannels(
    guildId: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<Array<ListGuildChannels200ResponseInner>>;

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listGuildEmojis(guildId: any, options?: RawAxiosRequestConfig): AxiosPromise<Array<EmojiResponse>>;

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listGuildIntegrations(
    guildId: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<Array<ListGuildIntegrations200ResponseInner>>;

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listGuildInvites(
    guildId: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<Array<ListChannelInvites200ResponseInner>>;

  /**
   *
   * @param {any} guildId
   * @param {number} [limit]
   * @param {number} [after]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listGuildMembers(
    guildId: any,
    limit?: number,
    after?: number,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<Array<GuildMemberResponse>>;

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listGuildRoles(guildId: any, options?: RawAxiosRequestConfig): AxiosPromise<Array<GuildRoleResponse>>;

  /**
   *
   * @param {any} guildId
   * @param {any} guildScheduledEventId
   * @param {boolean} [withMember]
   * @param {number} [limit]
   * @param {any} [before]
   * @param {any} [after]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listGuildScheduledEventUsers(
    guildId: any,
    guildScheduledEventId: any,
    withMember?: boolean,
    limit?: number,
    before?: any,
    after?: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<Array<ScheduledEventUserResponse>>;

  /**
   *
   * @param {any} guildId
   * @param {boolean} [withUserCount]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listGuildScheduledEvents(
    guildId: any,
    withUserCount?: boolean,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<Array<GetGuildScheduledEvent200Response>>;

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listGuildStickers(guildId: any, options?: RawAxiosRequestConfig): AxiosPromise<Array<GuildStickerResponse>>;

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listGuildTemplates(guildId: any, options?: RawAxiosRequestConfig): AxiosPromise<Array<GuildTemplateResponse>>;

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listGuildVoiceRegions(guildId: any, options?: RawAxiosRequestConfig): AxiosPromise<Array<VoiceRegionResponse>>;

  /**
   *
   * @param {any} channelId
   * @param {any} messageId
   * @param {string} emojiName
   * @param {any} [after]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listMessageReactionsByEmoji(
    channelId: any,
    messageId: any,
    emojiName: string,
    after?: any,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<Array<UserResponse>>;

  /**
   *
   * @param {any} channelId
   * @param {any} [around]
   * @param {any} [before]
   * @param {any} [after]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listMessages(
    channelId: any,
    around?: any,
    before?: any,
    after?: any,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<Array<MessageResponse>>;

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listMyConnections(options?: RawAxiosRequestConfig): AxiosPromise<Array<ConnectedAccountResponse>>;

  /**
   *
   * @param {any} [before]
   * @param {any} [after]
   * @param {number} [limit]
   * @param {boolean} [withCounts]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listMyGuilds(
    before?: any,
    after?: any,
    limit?: number,
    withCounts?: boolean,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<Array<MyGuildResponse>>;

  /**
   *
   * @param {any} channelId
   * @param {any} [before]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listMyPrivateArchivedThreads(
    channelId: any,
    before?: any,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ThreadsResponse>;

  /**
   *
   * @param {any} channelId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listPinnedMessages(channelId: any, options?: RawAxiosRequestConfig): AxiosPromise<Array<MessageResponse>>;

  /**
   *
   * @param {any} channelId
   * @param {string} [before]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listPrivateArchivedThreads(
    channelId: any,
    before?: string,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ThreadsResponse>;

  /**
   *
   * @param {any} channelId
   * @param {string} [before]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listPublicArchivedThreads(
    channelId: any,
    before?: string,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ThreadsResponse>;

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listStickerPacks(options?: RawAxiosRequestConfig): AxiosPromise<StickerPackCollectionResponse>;

  /**
   *
   * @param {any} channelId
   * @param {boolean} [withMember]
   * @param {number} [limit]
   * @param {any} [after]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listThreadMembers(
    channelId: any,
    withMember?: boolean,
    limit?: number,
    after?: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<Array<ThreadMemberResponse>>;

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  listVoiceRegions(options?: RawAxiosRequestConfig): AxiosPromise<Array<VoiceRegionResponse>>;

  /**
   *
   * @param {any} channelId
   * @param {any} messageId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  pinMessage(channelId: any, messageId: any, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @param {any} guildId
   * @param {number} [days]
   * @param {string | null} [includeRoles]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  previewPruneGuild(
    guildId: any,
    days?: number,
    includeRoles?: string | null,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GuildPruneResponse>;

  /**
   *
   * @param {any} guildId
   * @param {PruneGuildRequest} pruneGuildRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  pruneGuild(
    guildId: any,
    pruneGuildRequest: PruneGuildRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GuildPruneResponse>;

  /**
   *
   * @param {any} guildId
   * @param {UpdateGuildOnboardingRequest} updateGuildOnboardingRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  putGuildsOnboarding(
    guildId: any,
    updateGuildOnboardingRequest: UpdateGuildOnboardingRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GuildOnboardingResponse>;

  /**
   *
   * @param {number} limit
   * @param {string} query
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  searchGuildMembers(
    limit: number,
    query: string,
    guildId: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<Array<GuildMemberResponse>>;

  /**
   *
   * @param {any} channelId
   * @param {any} overwriteId
   * @param {SetChannelPermissionOverwriteRequest} setChannelPermissionOverwriteRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  setChannelPermissionOverwrite(
    channelId: any,
    overwriteId: any,
    setChannelPermissionOverwriteRequest: SetChannelPermissionOverwriteRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<void>;

  /**
   *
   * @param {any} applicationId
   * @param {any} guildId
   * @param {any} commandId
   * @param {SetGuildApplicationCommandPermissionsRequest} setGuildApplicationCommandPermissionsRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  setGuildApplicationCommandPermissions(
    applicationId: any,
    guildId: any,
    commandId: any,
    setGuildApplicationCommandPermissionsRequest: SetGuildApplicationCommandPermissionsRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<CommandPermissionsResponse>;

  /**
   *
   * @param {any} guildId
   * @param {SetGuildMfaLevelRequest} setGuildMfaLevelRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  setGuildMfaLevel(
    guildId: any,
    setGuildMfaLevelRequest: SetGuildMfaLevelRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GuildMFALevelResponse>;

  /**
   *
   * @param {any} guildId
   * @param {string} code
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  syncGuildTemplate(guildId: any, code: string, options?: RawAxiosRequestConfig): AxiosPromise<GuildTemplateResponse>;

  /**
   *
   * @param {any} channelId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  triggerTypingIndicator(channelId: any, options?: RawAxiosRequestConfig): AxiosPromise<any>;

  /**
   *
   * @param {any} guildId
   * @param {any} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  unbanUserFromGuild(guildId: any, userId: any, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @param {any} channelId
   * @param {any} messageId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  unpinMessage(channelId: any, messageId: any, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @param {any} applicationId
   * @param {ApplicationFormPartial} applicationFormPartial
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateApplication(
    applicationId: any,
    applicationFormPartial: ApplicationFormPartial,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<PrivateApplicationResponse>;

  /**
   *
   * @param {any} applicationId
   * @param {any} commandId
   * @param {ApplicationCommandPatchRequestPartial} applicationCommandPatchRequestPartial
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateApplicationCommand(
    applicationId: any,
    commandId: any,
    applicationCommandPatchRequestPartial: ApplicationCommandPatchRequestPartial,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ApplicationCommandResponse>;

  /**
   *
   * @param {any} applicationId
   * @param {Array<ApplicationRoleConnectionsMetadataItemRequest>} applicationRoleConnectionsMetadataItemRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateApplicationRoleConnectionsMetadata(
    applicationId: any,
    applicationRoleConnectionsMetadataItemRequest: Array<ApplicationRoleConnectionsMetadataItemRequest>,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<Array<ApplicationRoleConnectionsMetadataItemResponse>>;

  /**
   *
   * @param {any} applicationId
   * @param {UpdateApplicationUserRoleConnectionRequest} updateApplicationUserRoleConnectionRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateApplicationUserRoleConnection(
    applicationId: any,
    updateApplicationUserRoleConnectionRequest: UpdateApplicationUserRoleConnectionRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ApplicationUserRoleConnectionResponse>;

  /**
   *
   * @param {any} guildId
   * @param {any} ruleId
   * @param {UpdateAutoModerationRuleRequest} updateAutoModerationRuleRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateAutoModerationRule(
    guildId: any,
    ruleId: any,
    updateAutoModerationRuleRequest: UpdateAutoModerationRuleRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GetAutoModerationRule200Response>;

  /**
   *
   * @param {any} channelId
   * @param {UpdateChannelRequest} updateChannelRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateChannel(
    channelId: any,
    updateChannelRequest: UpdateChannelRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ListGuildChannels200ResponseInner>;

  /**
   *
   * @param {any} guildId
   * @param {GuildPatchRequestPartial} guildPatchRequestPartial
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateGuild(
    guildId: any,
    guildPatchRequestPartial: GuildPatchRequestPartial,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GuildResponse>;

  /**
   *
   * @param {any} applicationId
   * @param {any} guildId
   * @param {any} commandId
   * @param {ApplicationCommandPatchRequestPartial} applicationCommandPatchRequestPartial
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateGuildApplicationCommand(
    applicationId: any,
    guildId: any,
    commandId: any,
    applicationCommandPatchRequestPartial: ApplicationCommandPatchRequestPartial,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ApplicationCommandResponse>;

  /**
   *
   * @param {any} guildId
   * @param {any} emojiId
   * @param {UpdateGuildEmojiRequest} updateGuildEmojiRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateGuildEmoji(
    guildId: any,
    emojiId: any,
    updateGuildEmojiRequest: UpdateGuildEmojiRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<EmojiResponse>;

  /**
   *
   * @param {any} guildId
   * @param {any} userId
   * @param {UpdateGuildMemberRequest} updateGuildMemberRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateGuildMember(
    guildId: any,
    userId: any,
    updateGuildMemberRequest: UpdateGuildMemberRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GuildMemberResponse>;

  /**
   *
   * @param {any} guildId
   * @param {any} roleId
   * @param {UpdateGuildRoleRequest} updateGuildRoleRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateGuildRole(
    guildId: any,
    roleId: any,
    updateGuildRoleRequest: UpdateGuildRoleRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GuildRoleResponse>;

  /**
   *
   * @param {any} guildId
   * @param {any} guildScheduledEventId
   * @param {UpdateGuildScheduledEventRequest} updateGuildScheduledEventRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateGuildScheduledEvent(
    guildId: any,
    guildScheduledEventId: any,
    updateGuildScheduledEventRequest: UpdateGuildScheduledEventRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GetGuildScheduledEvent200Response>;

  /**
   *
   * @param {any} guildId
   * @param {any} stickerId
   * @param {UpdateGuildStickerRequest} updateGuildStickerRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateGuildSticker(
    guildId: any,
    stickerId: any,
    updateGuildStickerRequest: UpdateGuildStickerRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GuildStickerResponse>;

  /**
   *
   * @param {any} guildId
   * @param {string} code
   * @param {UpdateGuildTemplateRequest} updateGuildTemplateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateGuildTemplate(
    guildId: any,
    code: string,
    updateGuildTemplateRequest: UpdateGuildTemplateRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GuildTemplateResponse>;

  /**
   *
   * @param {any} guildId
   * @param {WelcomeScreenPatchRequestPartial} welcomeScreenPatchRequestPartial
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateGuildWelcomeScreen(
    guildId: any,
    welcomeScreenPatchRequestPartial: WelcomeScreenPatchRequestPartial,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<GuildWelcomeScreenResponse>;

  /**
   *
   * @param {any} guildId
   * @param {UpdateGuildWidgetSettingsRequest} updateGuildWidgetSettingsRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateGuildWidgetSettings(
    guildId: any,
    updateGuildWidgetSettingsRequest: UpdateGuildWidgetSettingsRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<WidgetSettingsResponse>;

  /**
   *
   * @param {any} channelId
   * @param {any} messageId
   * @param {MessageEditRequestPartial} messageEditRequestPartial
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateMessage(
    channelId: any,
    messageId: any,
    messageEditRequestPartial: MessageEditRequestPartial,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<MessageResponse>;

  /**
   *
   * @param {ApplicationFormPartial} applicationFormPartial
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateMyApplication(
    applicationFormPartial: ApplicationFormPartial,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<PrivateApplicationResponse>;

  /**
   *
   * @param {any} guildId
   * @param {UpdateMyGuildMemberRequest} updateMyGuildMemberRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateMyGuildMember(
    guildId: any,
    updateMyGuildMemberRequest: UpdateMyGuildMemberRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<PrivateGuildMemberResponse>;

  /**
   *
   * @param {BotAccountPatchRequest} botAccountPatchRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateMyUser(
    botAccountPatchRequest: BotAccountPatchRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<UserPIIResponse>;

  /**
   *
   * @param {any} webhookId
   * @param {string} webhookToken
   * @param {IncomingWebhookUpdateRequestPartial} incomingWebhookUpdateRequestPartial
   * @param {any} [threadId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateOriginalWebhookMessage(
    webhookId: any,
    webhookToken: string,
    incomingWebhookUpdateRequestPartial: IncomingWebhookUpdateRequestPartial,
    threadId?: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<MessageResponse>;

  /**
   *
   * @param {any} guildId
   * @param {UpdateSelfVoiceStateRequest} updateSelfVoiceStateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateSelfVoiceState(
    guildId: any,
    updateSelfVoiceStateRequest: UpdateSelfVoiceStateRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<void>;

  /**
   *
   * @param {any} channelId
   * @param {UpdateStageInstanceRequest} updateStageInstanceRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateStageInstance(
    channelId: any,
    updateStageInstanceRequest: UpdateStageInstanceRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<StageInstanceResponse>;

  /**
   *
   * @param {any} guildId
   * @param {any} userId
   * @param {UpdateVoiceStateRequest} updateVoiceStateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateVoiceState(
    guildId: any,
    userId: any,
    updateVoiceStateRequest: UpdateVoiceStateRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<void>;

  /**
   *
   * @param {any} webhookId
   * @param {UpdateWebhookRequest} updateWebhookRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateWebhook(
    webhookId: any,
    updateWebhookRequest: UpdateWebhookRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ListChannelWebhooks200ResponseInner>;

  /**
   *
   * @param {any} webhookId
   * @param {string} webhookToken
   * @param {UpdateWebhookByTokenRequest} updateWebhookByTokenRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateWebhookByToken(
    webhookId: any,
    webhookToken: string,
    updateWebhookByTokenRequest: UpdateWebhookByTokenRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<ListChannelWebhooks200ResponseInner>;

  /**
   *
   * @param {any} webhookId
   * @param {string} webhookToken
   * @param {any} messageId
   * @param {IncomingWebhookUpdateRequestPartial} incomingWebhookUpdateRequestPartial
   * @param {any} [threadId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApiInterface
   */
  updateWebhookMessage(
    webhookId: any,
    webhookToken: string,
    messageId: any,
    incomingWebhookUpdateRequestPartial: IncomingWebhookUpdateRequestPartial,
    threadId?: any,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<MessageResponse>;
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
  /**
   *
   * @param {any} channelId
   * @param {any} userId
   * @param {AddGroupDmUserRequest} addGroupDmUserRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public addGroupDmUser(
    channelId: any,
    userId: any,
    addGroupDmUserRequest: AddGroupDmUserRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .addGroupDmUser(channelId, userId, addGroupDmUserRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {any} userId
   * @param {AddGuildMemberRequest} addGuildMemberRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public addGuildMember(
    guildId: any,
    userId: any,
    addGuildMemberRequest: AddGuildMemberRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .addGuildMember(guildId, userId, addGuildMemberRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {any} userId
   * @param {any} roleId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public addGuildMemberRole(guildId: any, userId: any, roleId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .addGuildMemberRole(guildId, userId, roleId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {any} messageId
   * @param {string} emojiName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public addMyMessageReaction(channelId: any, messageId: any, emojiName: string, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .addMyMessageReaction(channelId, messageId, emojiName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {any} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public addThreadMember(channelId: any, userId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .addThreadMember(channelId, userId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {any} userId
   * @param {BanUserFromGuildRequest} banUserFromGuildRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public banUserFromGuild(
    guildId: any,
    userId: any,
    banUserFromGuildRequest: BanUserFromGuildRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .banUserFromGuild(guildId, userId, banUserFromGuildRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {BulkDeleteMessagesRequest} bulkDeleteMessagesRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public bulkDeleteMessages(
    channelId: any,
    bulkDeleteMessagesRequest: BulkDeleteMessagesRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .bulkDeleteMessages(channelId, bulkDeleteMessagesRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} applicationId
   * @param {Array<ApplicationCommandUpdateRequest>} applicationCommandUpdateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public bulkSetApplicationCommands(
    applicationId: any,
    applicationCommandUpdateRequest: Array<ApplicationCommandUpdateRequest>,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .bulkSetApplicationCommands(applicationId, applicationCommandUpdateRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} applicationId
   * @param {any} guildId
   * @param {Array<ApplicationCommandUpdateRequest>} applicationCommandUpdateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public bulkSetGuildApplicationCommands(
    applicationId: any,
    guildId: any,
    applicationCommandUpdateRequest: Array<ApplicationCommandUpdateRequest>,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .bulkSetGuildApplicationCommands(applicationId, guildId, applicationCommandUpdateRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {Array<BulkUpdateGuildChannelsRequestInner>} bulkUpdateGuildChannelsRequestInner
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public bulkUpdateGuildChannels(
    guildId: any,
    bulkUpdateGuildChannelsRequestInner: Array<BulkUpdateGuildChannelsRequestInner>,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .bulkUpdateGuildChannels(guildId, bulkUpdateGuildChannelsRequestInner, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {Array<BulkUpdateGuildRolesRequestInner>} bulkUpdateGuildRolesRequestInner
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public bulkUpdateGuildRoles(
    guildId: any,
    bulkUpdateGuildRolesRequestInner: Array<BulkUpdateGuildRolesRequestInner>,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .bulkUpdateGuildRoles(guildId, bulkUpdateGuildRolesRequestInner, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} applicationId
   * @param {ApplicationCommandCreateRequest} applicationCommandCreateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createApplicationCommand(
    applicationId: any,
    applicationCommandCreateRequest: ApplicationCommandCreateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .createApplicationCommand(applicationId, applicationCommandCreateRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {CreateAutoModerationRuleRequest} createAutoModerationRuleRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createAutoModerationRule(
    guildId: any,
    createAutoModerationRuleRequest: CreateAutoModerationRuleRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .createAutoModerationRule(guildId, createAutoModerationRuleRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {CreateChannelInviteRequest} createChannelInviteRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createChannelInvite(
    channelId: any,
    createChannelInviteRequest: CreateChannelInviteRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .createChannelInvite(channelId, createChannelInviteRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CreatePrivateChannelRequest} createPrivateChannelRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createDm(createPrivateChannelRequest: CreatePrivateChannelRequest, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .createDm(createPrivateChannelRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GuildCreateRequest} guildCreateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createGuild(guildCreateRequest: GuildCreateRequest, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .createGuild(guildCreateRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} applicationId
   * @param {any} guildId
   * @param {ApplicationCommandCreateRequest} applicationCommandCreateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createGuildApplicationCommand(
    applicationId: any,
    guildId: any,
    applicationCommandCreateRequest: ApplicationCommandCreateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .createGuildApplicationCommand(applicationId, guildId, applicationCommandCreateRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {CreateGuildChannelRequest} createGuildChannelRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createGuildChannel(
    guildId: any,
    createGuildChannelRequest: CreateGuildChannelRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .createGuildChannel(guildId, createGuildChannelRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {CreateGuildEmojiRequest} createGuildEmojiRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createGuildEmoji(
    guildId: any,
    createGuildEmojiRequest: CreateGuildEmojiRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .createGuildEmoji(guildId, createGuildEmojiRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} code
   * @param {CreateGuildFromTemplateRequest} createGuildFromTemplateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createGuildFromTemplate(
    code: string,
    createGuildFromTemplateRequest: CreateGuildFromTemplateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .createGuildFromTemplate(code, createGuildFromTemplateRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {UpdateGuildRoleRequest} updateGuildRoleRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createGuildRole(
    guildId: any,
    updateGuildRoleRequest: UpdateGuildRoleRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .createGuildRole(guildId, updateGuildRoleRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {CreateGuildScheduledEventRequest} createGuildScheduledEventRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createGuildScheduledEvent(
    guildId: any,
    createGuildScheduledEventRequest: CreateGuildScheduledEventRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .createGuildScheduledEvent(guildId, createGuildScheduledEventRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {string} name
   * @param {string} tags
   * @param {string} file
   * @param {string | null} [description]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createGuildSticker(
    guildId: any,
    name: string,
    tags: string,
    file: string,
    description?: string | null,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .createGuildSticker(guildId, name, tags, file, description, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {CreateGuildTemplateRequest} createGuildTemplateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createGuildTemplate(
    guildId: any,
    createGuildTemplateRequest: CreateGuildTemplateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .createGuildTemplate(guildId, createGuildTemplateRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} interactionId
   * @param {string} interactionToken
   * @param {CreateInteractionResponseRequest} createInteractionResponseRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createInteractionResponse(
    interactionId: any,
    interactionToken: string,
    createInteractionResponseRequest: CreateInteractionResponseRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .createInteractionResponse(interactionId, interactionToken, createInteractionResponseRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {MessageCreateRequest} messageCreateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createMessage(channelId: any, messageCreateRequest: MessageCreateRequest, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .createMessage(channelId, messageCreateRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CreateStageInstanceRequest} createStageInstanceRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createStageInstance(createStageInstanceRequest: CreateStageInstanceRequest, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .createStageInstance(createStageInstanceRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {CreateThreadRequest} createThreadRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createThread(channelId: any, createThreadRequest: CreateThreadRequest, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .createThread(channelId, createThreadRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {any} messageId
   * @param {CreateTextThreadWithMessageRequest} createTextThreadWithMessageRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createThreadFromMessage(
    channelId: any,
    messageId: any,
    createTextThreadWithMessageRequest: CreateTextThreadWithMessageRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .createThreadFromMessage(channelId, messageId, createTextThreadWithMessageRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {CreateWebhookRequest} createWebhookRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createWebhook(channelId: any, createWebhookRequest: CreateWebhookRequest, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .createWebhook(channelId, createWebhookRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {any} messageId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public crosspostMessage(channelId: any, messageId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .crosspostMessage(channelId, messageId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {any} messageId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteAllMessageReactions(channelId: any, messageId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .deleteAllMessageReactions(channelId, messageId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {any} messageId
   * @param {string} emojiName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteAllMessageReactionsByEmoji(
    channelId: any,
    messageId: any,
    emojiName: string,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .deleteAllMessageReactionsByEmoji(channelId, messageId, emojiName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} applicationId
   * @param {any} commandId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteApplicationCommand(applicationId: any, commandId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .deleteApplicationCommand(applicationId, commandId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {any} ruleId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteAutoModerationRule(guildId: any, ruleId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .deleteAutoModerationRule(guildId, ruleId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteChannel(channelId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .deleteChannel(channelId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {any} overwriteId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteChannelPermissionOverwrite(channelId: any, overwriteId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .deleteChannelPermissionOverwrite(channelId, overwriteId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {any} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteGroupDmUser(channelId: any, userId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .deleteGroupDmUser(channelId, userId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteGuild(guildId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .deleteGuild(guildId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} applicationId
   * @param {any} guildId
   * @param {any} commandId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteGuildApplicationCommand(
    applicationId: any,
    guildId: any,
    commandId: any,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .deleteGuildApplicationCommand(applicationId, guildId, commandId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {any} emojiId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteGuildEmoji(guildId: any, emojiId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .deleteGuildEmoji(guildId, emojiId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {any} integrationId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteGuildIntegration(guildId: any, integrationId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .deleteGuildIntegration(guildId, integrationId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {any} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteGuildMember(guildId: any, userId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .deleteGuildMember(guildId, userId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {any} userId
   * @param {any} roleId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteGuildMemberRole(guildId: any, userId: any, roleId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .deleteGuildMemberRole(guildId, userId, roleId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {any} roleId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteGuildRole(guildId: any, roleId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .deleteGuildRole(guildId, roleId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {any} guildScheduledEventId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteGuildScheduledEvent(guildId: any, guildScheduledEventId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .deleteGuildScheduledEvent(guildId, guildScheduledEventId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {any} stickerId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteGuildSticker(guildId: any, stickerId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .deleteGuildSticker(guildId, stickerId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {string} code
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteGuildTemplate(guildId: any, code: string, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .deleteGuildTemplate(guildId, code, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {any} messageId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteMessage(channelId: any, messageId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .deleteMessage(channelId, messageId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {any} messageId
   * @param {string} emojiName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteMyMessageReaction(channelId: any, messageId: any, emojiName: string, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .deleteMyMessageReaction(channelId, messageId, emojiName, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} webhookId
   * @param {string} webhookToken
   * @param {any} [threadId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteOriginalWebhookMessage(
    webhookId: any,
    webhookToken: string,
    threadId?: any,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .deleteOriginalWebhookMessage(webhookId, webhookToken, threadId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteStageInstance(channelId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .deleteStageInstance(channelId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {any} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteThreadMember(channelId: any, userId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .deleteThreadMember(channelId, userId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {any} messageId
   * @param {string} emojiName
   * @param {any} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteUserMessageReaction(
    channelId: any,
    messageId: any,
    emojiName: string,
    userId: any,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .deleteUserMessageReaction(channelId, messageId, emojiName, userId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} webhookId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteWebhook(webhookId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .deleteWebhook(webhookId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} webhookId
   * @param {string} webhookToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteWebhookByToken(webhookId: any, webhookToken: string, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .deleteWebhookByToken(webhookId, webhookToken, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} webhookId
   * @param {string} webhookToken
   * @param {any} messageId
   * @param {any} [threadId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteWebhookMessage(
    webhookId: any,
    webhookToken: string,
    messageId: any,
    threadId?: any,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .deleteWebhookMessage(webhookId, webhookToken, messageId, threadId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} webhookId
   * @param {string} webhookToken
   * @param {GithubWebhook} githubWebhook
   * @param {boolean} [wait]
   * @param {any} [threadId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public executeGithubCompatibleWebhook(
    webhookId: any,
    webhookToken: string,
    githubWebhook: GithubWebhook,
    wait?: boolean,
    threadId?: any,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .executeGithubCompatibleWebhook(webhookId, webhookToken, githubWebhook, wait, threadId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} webhookId
   * @param {string} webhookToken
   * @param {SlackWebhook} slackWebhook
   * @param {boolean} [wait]
   * @param {any} [threadId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public executeSlackCompatibleWebhook(
    webhookId: any,
    webhookToken: string,
    slackWebhook: SlackWebhook,
    wait?: boolean,
    threadId?: any,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .executeSlackCompatibleWebhook(webhookId, webhookToken, slackWebhook, wait, threadId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} webhookId
   * @param {string} webhookToken
   * @param {ExecuteWebhookRequest} executeWebhookRequest
   * @param {boolean} [wait]
   * @param {any} [threadId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public executeWebhook(
    webhookId: any,
    webhookToken: string,
    executeWebhookRequest: ExecuteWebhookRequest,
    wait?: boolean,
    threadId?: any,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .executeWebhook(webhookId, webhookToken, executeWebhookRequest, wait, threadId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {FollowChannelRequest} followChannelRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public followChannel(channelId: any, followChannelRequest: FollowChannelRequest, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .followChannel(channelId, followChannelRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getActiveGuildThreads(guildId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getActiveGuildThreads(guildId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} applicationId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getApplication(applicationId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getApplication(applicationId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} applicationId
   * @param {any} commandId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getApplicationCommand(applicationId: any, commandId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getApplicationCommand(applicationId, commandId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} applicationId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getApplicationRoleConnectionsMetadata(applicationId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getApplicationRoleConnectionsMetadata(applicationId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} applicationId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getApplicationUserRoleConnection(applicationId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getApplicationUserRoleConnection(applicationId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {any} ruleId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getAutoModerationRule(guildId: any, ruleId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getAutoModerationRule(guildId, ruleId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getBotGateway(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getBotGateway(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getChannel(channelId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getChannel(channelId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getGateway(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getGateway(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {boolean} [withCounts]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getGuild(guildId: any, withCounts?: boolean, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getGuild(guildId, withCounts, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} applicationId
   * @param {any} guildId
   * @param {any} commandId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getGuildApplicationCommand(applicationId: any, guildId: any, commandId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getGuildApplicationCommand(applicationId, guildId, commandId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} applicationId
   * @param {any} guildId
   * @param {any} commandId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getGuildApplicationCommandPermissions(
    applicationId: any,
    guildId: any,
    commandId: any,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .getGuildApplicationCommandPermissions(applicationId, guildId, commandId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {any} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getGuildBan(guildId: any, userId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getGuildBan(guildId, userId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {any} emojiId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getGuildEmoji(guildId: any, emojiId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getGuildEmoji(guildId, emojiId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {any} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getGuildMember(guildId: any, userId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getGuildMember(guildId, userId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getGuildNewMemberWelcome(guildId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getGuildNewMemberWelcome(guildId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getGuildPreview(guildId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getGuildPreview(guildId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {any} guildScheduledEventId
   * @param {boolean} [withUserCount]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getGuildScheduledEvent(
    guildId: any,
    guildScheduledEventId: any,
    withUserCount?: boolean,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .getGuildScheduledEvent(guildId, guildScheduledEventId, withUserCount, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {any} stickerId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getGuildSticker(guildId: any, stickerId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getGuildSticker(guildId, stickerId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} code
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getGuildTemplate(code: string, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getGuildTemplate(code, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getGuildVanityUrl(guildId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getGuildVanityUrl(guildId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getGuildWebhooks(guildId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getGuildWebhooks(guildId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getGuildWelcomeScreen(guildId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getGuildWelcomeScreen(guildId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getGuildWidget(guildId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getGuildWidget(guildId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {WidgetImageStyles} [style]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getGuildWidgetPng(guildId: any, style?: WidgetImageStyles, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getGuildWidgetPng(guildId, style, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getGuildWidgetSettings(guildId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getGuildWidgetSettings(guildId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getGuildsOnboarding(guildId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getGuildsOnboarding(guildId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {any} messageId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getMessage(channelId: any, messageId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getMessage(channelId, messageId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getMyApplication(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getMyApplication(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getMyGuildMember(guildId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getMyGuildMember(guildId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getMyOauth2Application(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getMyOauth2Application(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getMyOauth2Authorization(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getMyOauth2Authorization(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getMyUser(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getMyUser(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} webhookId
   * @param {string} webhookToken
   * @param {any} [threadId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getOriginalWebhookMessage(
    webhookId: any,
    webhookToken: string,
    threadId?: any,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .getOriginalWebhookMessage(webhookId, webhookToken, threadId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getStageInstance(channelId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getStageInstance(channelId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} stickerId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getSticker(stickerId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getSticker(stickerId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {any} userId
   * @param {boolean} [withMember]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getThreadMember(channelId: any, userId: any, withMember?: boolean, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getThreadMember(channelId, userId, withMember, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getUser(userId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getUser(userId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} webhookId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getWebhook(webhookId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getWebhook(webhookId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} webhookId
   * @param {string} webhookToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getWebhookByToken(webhookId: any, webhookToken: string, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .getWebhookByToken(webhookId, webhookToken, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} webhookId
   * @param {string} webhookToken
   * @param {any} messageId
   * @param {any} [threadId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getWebhookMessage(
    webhookId: any,
    webhookToken: string,
    messageId: any,
    threadId?: any,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .getWebhookMessage(webhookId, webhookToken, messageId, threadId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} code
   * @param {boolean} [withCounts]
   * @param {any} [guildScheduledEventId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public inviteResolve(
    code: string,
    withCounts?: boolean,
    guildScheduledEventId?: any,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .inviteResolve(code, withCounts, guildScheduledEventId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} code
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public inviteRevoke(code: string, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .inviteRevoke(code, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public joinThread(channelId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .joinThread(channelId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public leaveGuild(guildId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .leaveGuild(guildId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public leaveThread(channelId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .leaveThread(channelId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} applicationId
   * @param {boolean} [withLocalizations]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listApplicationCommands(applicationId: any, withLocalizations?: boolean, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .listApplicationCommands(applicationId, withLocalizations, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listAutoModerationRules(guildId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .listAutoModerationRules(guildId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listChannelInvites(channelId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .listChannelInvites(channelId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listChannelWebhooks(channelId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .listChannelWebhooks(channelId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} applicationId
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listGuildApplicationCommandPermissions(applicationId: any, guildId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .listGuildApplicationCommandPermissions(applicationId, guildId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} applicationId
   * @param {any} guildId
   * @param {boolean} [withLocalizations]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listGuildApplicationCommands(
    applicationId: any,
    guildId: any,
    withLocalizations?: boolean,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .listGuildApplicationCommands(applicationId, guildId, withLocalizations, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {any} [userId]
   * @param {number} [actionType]
   * @param {any} [before]
   * @param {any} [after]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listGuildAuditLogEntries(
    guildId: any,
    userId?: any,
    actionType?: number,
    before?: any,
    after?: any,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .listGuildAuditLogEntries(guildId, userId, actionType, before, after, limit, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {number} [limit]
   * @param {any} [before]
   * @param {any} [after]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listGuildBans(guildId: any, limit?: number, before?: any, after?: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .listGuildBans(guildId, limit, before, after, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listGuildChannels(guildId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .listGuildChannels(guildId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listGuildEmojis(guildId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .listGuildEmojis(guildId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listGuildIntegrations(guildId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .listGuildIntegrations(guildId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listGuildInvites(guildId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .listGuildInvites(guildId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {number} [limit]
   * @param {number} [after]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listGuildMembers(guildId: any, limit?: number, after?: number, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .listGuildMembers(guildId, limit, after, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listGuildRoles(guildId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .listGuildRoles(guildId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {any} guildScheduledEventId
   * @param {boolean} [withMember]
   * @param {number} [limit]
   * @param {any} [before]
   * @param {any} [after]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listGuildScheduledEventUsers(
    guildId: any,
    guildScheduledEventId: any,
    withMember?: boolean,
    limit?: number,
    before?: any,
    after?: any,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .listGuildScheduledEventUsers(guildId, guildScheduledEventId, withMember, limit, before, after, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {boolean} [withUserCount]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listGuildScheduledEvents(guildId: any, withUserCount?: boolean, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .listGuildScheduledEvents(guildId, withUserCount, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listGuildStickers(guildId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .listGuildStickers(guildId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listGuildTemplates(guildId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .listGuildTemplates(guildId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listGuildVoiceRegions(guildId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .listGuildVoiceRegions(guildId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {any} messageId
   * @param {string} emojiName
   * @param {any} [after]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listMessageReactionsByEmoji(
    channelId: any,
    messageId: any,
    emojiName: string,
    after?: any,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .listMessageReactionsByEmoji(channelId, messageId, emojiName, after, limit, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {any} [around]
   * @param {any} [before]
   * @param {any} [after]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listMessages(
    channelId: any,
    around?: any,
    before?: any,
    after?: any,
    limit?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .listMessages(channelId, around, before, after, limit, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listMyConnections(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .listMyConnections(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} [before]
   * @param {any} [after]
   * @param {number} [limit]
   * @param {boolean} [withCounts]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listMyGuilds(
    before?: any,
    after?: any,
    limit?: number,
    withCounts?: boolean,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .listMyGuilds(before, after, limit, withCounts, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {any} [before]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listMyPrivateArchivedThreads(channelId: any, before?: any, limit?: number, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .listMyPrivateArchivedThreads(channelId, before, limit, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listPinnedMessages(channelId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .listPinnedMessages(channelId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {string} [before]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listPrivateArchivedThreads(channelId: any, before?: string, limit?: number, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .listPrivateArchivedThreads(channelId, before, limit, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {string} [before]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listPublicArchivedThreads(channelId: any, before?: string, limit?: number, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .listPublicArchivedThreads(channelId, before, limit, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listStickerPacks(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .listStickerPacks(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {boolean} [withMember]
   * @param {number} [limit]
   * @param {any} [after]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listThreadMembers(
    channelId: any,
    withMember?: boolean,
    limit?: number,
    after?: any,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .listThreadMembers(channelId, withMember, limit, after, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listVoiceRegions(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .listVoiceRegions(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {any} messageId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public pinMessage(channelId: any, messageId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .pinMessage(channelId, messageId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {number} [days]
   * @param {string | null} [includeRoles]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public previewPruneGuild(guildId: any, days?: number, includeRoles?: string | null, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .previewPruneGuild(guildId, days, includeRoles, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {PruneGuildRequest} pruneGuildRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public pruneGuild(guildId: any, pruneGuildRequest: PruneGuildRequest, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .pruneGuild(guildId, pruneGuildRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {UpdateGuildOnboardingRequest} updateGuildOnboardingRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public putGuildsOnboarding(
    guildId: any,
    updateGuildOnboardingRequest: UpdateGuildOnboardingRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .putGuildsOnboarding(guildId, updateGuildOnboardingRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {number} limit
   * @param {string} query
   * @param {any} guildId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public searchGuildMembers(limit: number, query: string, guildId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .searchGuildMembers(limit, query, guildId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {any} overwriteId
   * @param {SetChannelPermissionOverwriteRequest} setChannelPermissionOverwriteRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public setChannelPermissionOverwrite(
    channelId: any,
    overwriteId: any,
    setChannelPermissionOverwriteRequest: SetChannelPermissionOverwriteRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .setChannelPermissionOverwrite(channelId, overwriteId, setChannelPermissionOverwriteRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} applicationId
   * @param {any} guildId
   * @param {any} commandId
   * @param {SetGuildApplicationCommandPermissionsRequest} setGuildApplicationCommandPermissionsRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public setGuildApplicationCommandPermissions(
    applicationId: any,
    guildId: any,
    commandId: any,
    setGuildApplicationCommandPermissionsRequest: SetGuildApplicationCommandPermissionsRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .setGuildApplicationCommandPermissions(
        applicationId,
        guildId,
        commandId,
        setGuildApplicationCommandPermissionsRequest,
        options,
      )
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {SetGuildMfaLevelRequest} setGuildMfaLevelRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public setGuildMfaLevel(
    guildId: any,
    setGuildMfaLevelRequest: SetGuildMfaLevelRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .setGuildMfaLevel(guildId, setGuildMfaLevelRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {string} code
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public syncGuildTemplate(guildId: any, code: string, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .syncGuildTemplate(guildId, code, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public triggerTypingIndicator(channelId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .triggerTypingIndicator(channelId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {any} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public unbanUserFromGuild(guildId: any, userId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .unbanUserFromGuild(guildId, userId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {any} messageId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public unpinMessage(channelId: any, messageId: any, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .unpinMessage(channelId, messageId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} applicationId
   * @param {ApplicationFormPartial} applicationFormPartial
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateApplication(
    applicationId: any,
    applicationFormPartial: ApplicationFormPartial,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updateApplication(applicationId, applicationFormPartial, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} applicationId
   * @param {any} commandId
   * @param {ApplicationCommandPatchRequestPartial} applicationCommandPatchRequestPartial
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateApplicationCommand(
    applicationId: any,
    commandId: any,
    applicationCommandPatchRequestPartial: ApplicationCommandPatchRequestPartial,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updateApplicationCommand(applicationId, commandId, applicationCommandPatchRequestPartial, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} applicationId
   * @param {Array<ApplicationRoleConnectionsMetadataItemRequest>} applicationRoleConnectionsMetadataItemRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateApplicationRoleConnectionsMetadata(
    applicationId: any,
    applicationRoleConnectionsMetadataItemRequest: Array<ApplicationRoleConnectionsMetadataItemRequest>,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updateApplicationRoleConnectionsMetadata(applicationId, applicationRoleConnectionsMetadataItemRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} applicationId
   * @param {UpdateApplicationUserRoleConnectionRequest} updateApplicationUserRoleConnectionRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateApplicationUserRoleConnection(
    applicationId: any,
    updateApplicationUserRoleConnectionRequest: UpdateApplicationUserRoleConnectionRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updateApplicationUserRoleConnection(applicationId, updateApplicationUserRoleConnectionRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {any} ruleId
   * @param {UpdateAutoModerationRuleRequest} updateAutoModerationRuleRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateAutoModerationRule(
    guildId: any,
    ruleId: any,
    updateAutoModerationRuleRequest: UpdateAutoModerationRuleRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updateAutoModerationRule(guildId, ruleId, updateAutoModerationRuleRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {UpdateChannelRequest} updateChannelRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateChannel(channelId: any, updateChannelRequest: UpdateChannelRequest, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .updateChannel(channelId, updateChannelRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {GuildPatchRequestPartial} guildPatchRequestPartial
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateGuild(
    guildId: any,
    guildPatchRequestPartial: GuildPatchRequestPartial,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updateGuild(guildId, guildPatchRequestPartial, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} applicationId
   * @param {any} guildId
   * @param {any} commandId
   * @param {ApplicationCommandPatchRequestPartial} applicationCommandPatchRequestPartial
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateGuildApplicationCommand(
    applicationId: any,
    guildId: any,
    commandId: any,
    applicationCommandPatchRequestPartial: ApplicationCommandPatchRequestPartial,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updateGuildApplicationCommand(applicationId, guildId, commandId, applicationCommandPatchRequestPartial, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {any} emojiId
   * @param {UpdateGuildEmojiRequest} updateGuildEmojiRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateGuildEmoji(
    guildId: any,
    emojiId: any,
    updateGuildEmojiRequest: UpdateGuildEmojiRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updateGuildEmoji(guildId, emojiId, updateGuildEmojiRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {any} userId
   * @param {UpdateGuildMemberRequest} updateGuildMemberRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateGuildMember(
    guildId: any,
    userId: any,
    updateGuildMemberRequest: UpdateGuildMemberRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updateGuildMember(guildId, userId, updateGuildMemberRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {any} roleId
   * @param {UpdateGuildRoleRequest} updateGuildRoleRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateGuildRole(
    guildId: any,
    roleId: any,
    updateGuildRoleRequest: UpdateGuildRoleRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updateGuildRole(guildId, roleId, updateGuildRoleRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {any} guildScheduledEventId
   * @param {UpdateGuildScheduledEventRequest} updateGuildScheduledEventRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateGuildScheduledEvent(
    guildId: any,
    guildScheduledEventId: any,
    updateGuildScheduledEventRequest: UpdateGuildScheduledEventRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updateGuildScheduledEvent(guildId, guildScheduledEventId, updateGuildScheduledEventRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {any} stickerId
   * @param {UpdateGuildStickerRequest} updateGuildStickerRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateGuildSticker(
    guildId: any,
    stickerId: any,
    updateGuildStickerRequest: UpdateGuildStickerRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updateGuildSticker(guildId, stickerId, updateGuildStickerRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {string} code
   * @param {UpdateGuildTemplateRequest} updateGuildTemplateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateGuildTemplate(
    guildId: any,
    code: string,
    updateGuildTemplateRequest: UpdateGuildTemplateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updateGuildTemplate(guildId, code, updateGuildTemplateRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {WelcomeScreenPatchRequestPartial} welcomeScreenPatchRequestPartial
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateGuildWelcomeScreen(
    guildId: any,
    welcomeScreenPatchRequestPartial: WelcomeScreenPatchRequestPartial,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updateGuildWelcomeScreen(guildId, welcomeScreenPatchRequestPartial, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {UpdateGuildWidgetSettingsRequest} updateGuildWidgetSettingsRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateGuildWidgetSettings(
    guildId: any,
    updateGuildWidgetSettingsRequest: UpdateGuildWidgetSettingsRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updateGuildWidgetSettings(guildId, updateGuildWidgetSettingsRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {any} messageId
   * @param {MessageEditRequestPartial} messageEditRequestPartial
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateMessage(
    channelId: any,
    messageId: any,
    messageEditRequestPartial: MessageEditRequestPartial,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updateMessage(channelId, messageId, messageEditRequestPartial, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ApplicationFormPartial} applicationFormPartial
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateMyApplication(applicationFormPartial: ApplicationFormPartial, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .updateMyApplication(applicationFormPartial, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {UpdateMyGuildMemberRequest} updateMyGuildMemberRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateMyGuildMember(
    guildId: any,
    updateMyGuildMemberRequest: UpdateMyGuildMemberRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updateMyGuildMember(guildId, updateMyGuildMemberRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {BotAccountPatchRequest} botAccountPatchRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateMyUser(botAccountPatchRequest: BotAccountPatchRequest, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .updateMyUser(botAccountPatchRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} webhookId
   * @param {string} webhookToken
   * @param {IncomingWebhookUpdateRequestPartial} incomingWebhookUpdateRequestPartial
   * @param {any} [threadId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateOriginalWebhookMessage(
    webhookId: any,
    webhookToken: string,
    incomingWebhookUpdateRequestPartial: IncomingWebhookUpdateRequestPartial,
    threadId?: any,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updateOriginalWebhookMessage(webhookId, webhookToken, incomingWebhookUpdateRequestPartial, threadId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {UpdateSelfVoiceStateRequest} updateSelfVoiceStateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateSelfVoiceState(
    guildId: any,
    updateSelfVoiceStateRequest: UpdateSelfVoiceStateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updateSelfVoiceState(guildId, updateSelfVoiceStateRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} channelId
   * @param {UpdateStageInstanceRequest} updateStageInstanceRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateStageInstance(
    channelId: any,
    updateStageInstanceRequest: UpdateStageInstanceRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updateStageInstance(channelId, updateStageInstanceRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} guildId
   * @param {any} userId
   * @param {UpdateVoiceStateRequest} updateVoiceStateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateVoiceState(
    guildId: any,
    userId: any,
    updateVoiceStateRequest: UpdateVoiceStateRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updateVoiceState(guildId, userId, updateVoiceStateRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} webhookId
   * @param {UpdateWebhookRequest} updateWebhookRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateWebhook(webhookId: any, updateWebhookRequest: UpdateWebhookRequest, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .updateWebhook(webhookId, updateWebhookRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} webhookId
   * @param {string} webhookToken
   * @param {UpdateWebhookByTokenRequest} updateWebhookByTokenRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateWebhookByToken(
    webhookId: any,
    webhookToken: string,
    updateWebhookByTokenRequest: UpdateWebhookByTokenRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updateWebhookByToken(webhookId, webhookToken, updateWebhookByTokenRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} webhookId
   * @param {string} webhookToken
   * @param {any} messageId
   * @param {IncomingWebhookUpdateRequestPartial} incomingWebhookUpdateRequestPartial
   * @param {any} [threadId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateWebhookMessage(
    webhookId: any,
    webhookToken: string,
    messageId: any,
    incomingWebhookUpdateRequestPartial: IncomingWebhookUpdateRequestPartial,
    threadId?: any,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .updateWebhookMessage(webhookId, webhookToken, messageId, incomingWebhookUpdateRequestPartial, threadId, options)
      .then(request => request(this.axios, this.basePath));
  }
}
